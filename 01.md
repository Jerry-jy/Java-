# J2EE 知识点总结

Java：跨平台的语言（能运行在Windows，Mac OS，Linux等操作系统之上）

Write Once， Run Anywhere！

JVM：跨语言的平台（能为Java，Python，Kotlin等语言编译字节码）

**JDK**(Java Development Kit Java开发工具包)：是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了 JRE。所以安装了JDK，就不用在单独安装JRE了。



JRE(Java Runtime Environment Java运行环境)  包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等， 如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。

JDK = JRE + 开发工具集（例如Javac编译工具等）

JRE = JVM + Java SE标准类库



正数的原码、反码、补码都相同

负数的反码：是对原码按位取反(中间态)

负数的补码：其反码加1。计算机底层都是使用的数值的补码保存数据的。



“&”和“&&”的区别：

单&时，左边无论真假，右边都进行运算；

双&时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。



javadoc文档解析

```bash
javadoc -encoding UTF-8 -charset UTF-8 -d myhello -author -version HelloWorld.java
```

java入门问题1——javadoc解析时，cmd窗口报错：编码GBK的不可映射字符
问题1描述：在cmd中运行命令，javadoc -d myhello -author -version HelloJava.java  时，报错编码GBK的不可映射字符。

解决方法：经过网页查询，且前提为使用编码UTF-8（其他编码对应更改就可以），将cmd中的命令改为javadoc -encoding UTF-8 -charset UTF-8 -d myhello -author -version HelloJava.java

上述问题得到解决，但出现了新的问题。

问题2描述：javadoc错误-找不到可以文档化的公共或受保护的类。

解决方法：在源文件中的class前加入public后，可以成功运行。

# 数组

 一维数组的声明方式： type var[] 或 type[] var；



java.util.Arrays常用工具类

 boolean equals(int[] a,int[] b) 判断两个数组是否相等。 

String toString(int[] a) 输出数组信息。 

void fill(int[] a,int val) 将指定值填充到数组之中。 

 void sort(int[] a) 对数组进行排序。 

 int binarySearch(int[] a,int key) 对排序后的数组进行二分法检索指定的值。

```java
int[] copyOfRange(int[] original, int from, int to)
```



## **选择排序 ：**

 **(直接)简单选择排序：**

每次都从一组无序数组中选一个最小的，然后和第一个对调。

**堆排序：**

1)根据初始数组去构造初始堆

1.1）建初始堆的过程：先将一个无序数组按照从上到小，从左到右排列成完全二叉树。

然后再从最后一个非叶子结点开始，从右到左、从下到上调整为大顶堆。

2）交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下的元素调整为大顶堆，再交换第一个和最后一个元素，输出最后一个元素再调整剩下的元素为大顶堆，重复这个操作，直至整个数组排序完成。

## **交换排序** ：

**冒泡排序**

比如说从小到大排序：依次比较相邻的两个元素，大的放右边。重复n-1轮

**快速排序** 

一次划分的过程：有2个指针，low指针指向头元素，high指针指向尾元素，一般取第一个元素为界点（标准）元素，为了减少数据移动，将标准元素暂存在R[0]中（此时的low指针指向空）最后再放入最终位置。开始high指针从后往前移动，找比界点元素小的元素，放在low指针的位置（此时的high指针为空），然后low指针从前往后移动，找比界点元素大的元素，放在high指针的位置。重复上述的过程知道low指针和high指针位置重合，把界点元素放在该位置。

重复划分过程。

## **插入排序** 

**直接插入排序**

从一组无序数组的第2位开始，每次只和它前面的数进行比较，直接插入在正确的位置

**Shell排序 （缩小增量排序）**

比如有8个元素一组的无序数组，

第一趟（d=4）：第5个位置元素和第1个位置元素比大小，小的话就交换位置（大的放后面），第6个位置元素和第2个位置元素比大小，第7个位置元素和第3个位置元素比大小，第8个位置元素和第4个位置元素比大小

第二趟（d=2）：第4个位置元素和第2个位置元素比大小，小的话就交换位置（大的放后面），第6个位置元素和第4个位置元素比大小，第8个位置元素和第6个位置元素比大小，大的放后面

然后：第3个位置元素和第1个位置元素比大小，小的话就交换位置（大的放后面），第5个位置元素和第3个位置元素比大小，第7个位置元素和第5个位置元素比大小，大的放后面

第三趟（d=1）：后一个位置和前一个位置元素比大小，小的话就交换位置（大的放后面）

**折半插入排序**

折半插入排序是对直接插入排序的一种改良方式，

**二路归并排序**

将一组无序数组，分为左右一半，不停的进行递归拆分，递归深度为log2n，直到分为单个元素不可再分为止

我们将单个元素进行排序合成一个有序序列



**计数排序**

一组有确定范围的无序数组，申请一个大小为arr.length+1长度的数组，下标从arr[0]~arr[length]，默认初始化为0，开始计每一个数出现的次数，就在对应下标的数的位置填出现的次数，然后遍历输出这个数组。



**桶式排序**

是计数排序的升级版。原理是：假设输入的数据服从均匀分布，将数据分配到有限数量的桶中，再对每个桶分别进行排序。分配的原则是利用函数映射关系，整个算法的高效与否就在于这个映射函数的确定。

思路：

1、根据待排序集合中的数据，确定映射规则和桶的数量；

2、遍历待排序数组，将每一个元素根据映射规则，移动到对应的桶里；

3、对每一个桶中的元素进行排序

4、依次输出每个桶中的数据，得到整个有序集合

步骤：

1、找到待排序数组中的最大值amx，和最小值min

2、桶的数量为：（max-min）/  arr.length  + 1，桶的下标是从0开始

3、映射函数的对映规则：也就是存放桶的下标=（arr[i] - min）/ arr.length

4、这时候，每个桶里的数据是无序，但是随着桶的下标递增，桶里的数据是递增

5、再对每个桶里的数据进行排序。桶内排序可以选择比较排序或者其他排序

6、遍历桶数组



**基数排序**

先把无序数组变成位数都一样，不足的高位补0，然后先按照低位排好序，再按照高位排好序，依次类推，直到最高位，最后遍历输出数组就行



十大排序算法的代码具体实现，详情见《数据结构》专栏

# 面向对象

## 重载（**Overload**）的概念

在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。 

重载的特点： 与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类 型)。调用时，根据方法参数列表的不同来区别。



## **Override重写(覆盖)：**

表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法（子类重写父类中的方法），是面向对象编程的中多态性的一种表现。

要求：

1. 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表 
2.  子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型 
3. 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限 
   1. 子类不能重写父类中声明为private权限的方法 
4. 子类方法抛出的异常不能大于父类被重写方法的异常

注意： 子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为 static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法

**overwrite重写：**

**java官方文档没有该词的出现，所以java中就没有它的存在**，但是也有人把overwrite解释为override。



在**C++**中将Override和overwrite进行了区分。

Override(覆盖):

是指派生类函数覆盖基类函数，特征是：

（1）不同的范围（分别位于派生类与基类）；

（2）函数名字相同；

（3）参数相同；

（4）基类函数必须有virtual 关键字。

Overwrite(重写):

是指派生类的函数屏蔽了与其同名的基类函数，规则如下：

（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏。

（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏。





## 构造器的作用：

创建对象；

给对象进行初始化



总结：属性赋值过程

赋值的位置： ① 默认初始化 ② 显式初始化 ③ 构造器中初始化 ④ 通过“对象.属性“或“对象.方法”的方式赋值 

赋值的先后顺序： ① - ② - ③ - ④



## **JavaBean**

JavaBean是一种Java语言写成的可重用组件。

所谓JavaBean，是指符合如下标准的Java类： 

类是公共的 

有一个无参的公共的构造器 

有属性，且有对应的get、set方法

 用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以 用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP 页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用 户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关 心任何改变。

```java
package com.jerry.java;

/**
 * @author jerry_jy
 * @create 2022-09-27 10:32
 */
public class JavaBean {//类是公共的
    private String name;//有属性，且有对应的get、set方法
    private int age;
    public JavaBean(){//有一个无参的公共的构造器

    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```

![image-20220928103557778](E:/typora/image-20220928103557778.png)

对于class的权限修饰只可以用public和default(缺省)。 

​	 public类可以在任意地方被访问。 

​	default类只可以被同一个包内部的类访问。

## **多态性**

是面向对象中最重要的概念，在Java中的体现： 对象的多态性：父类的引用指向子类的对象

Person p = new Student(); //Person类型的变量p，指向Student类型的对象

Object o = new Person();//Object类型的变量o，指向Person类型的对象 

o = new Student(); //Object类型的变量o，指向Student类型的对象

子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：**向上转型(upcasting)**。

一个引用类型变量如果声明为**父类的类型**，但实际引用的是子类 对象，那么该变量就不能再访问子类中添加的属性和方法

Student m = new Student(); 

m.school = “pku”; //合法,Student类有school成员变量 

Person e = new Student();  

e.school = “pku”; //非法,Person类没有school成员变量 

属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。



虚拟方法调用(多态情况下)(Virtual Method Invocation）

子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父 类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。



## instanceof 操作符

x instanceof A：检验x是否为类A的对象，返回值为boolean型。 

要求x所属的类与类A必须是子类和父类的关系，否则编译错误。 

如果x属于类A的子类B，x instanceof A值也为true。



Object类是所有Java类的根父类

 如果在类的声明中未使用extends关键字指明其父类，则默认父类 为java.lang.Object类

public class Person { ... } 等价于： public class Person extends Object { ... }

例：method(Object obj){…} //可以接收任何类作为其参数 

Person o=new Person(); 

method(o);



## ==操作符与equals方法：

**==操作符**

基本类型比较值:只要两个变量的值相等，即为true。

引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true。

用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本 数据类型除外)，否则编译出错



equals()：所有类都继承了Object，也就获得了equals()方法。还可以重写。

只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。

格式:obj1.equals(obj2)

特例：当用equals()方法进行比较时，对类File、String、Date及包装类 （Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对 象；原因：在这些类中重写了Object类的equals()方法。



面试题：==和equals的区别

1 == 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型 就是比较内存地址 

2 equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也 是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中 用的比较多，久而久之，形成了equals是比较值的错误观点。 

3 具体要看自定义类里有没有重写Object的equals方法来判断。 

4 通常情况下，重写equals方法，会比较类中的相应属性是否都相等。



**toString() 方法**

toString()方法在Object类中定义，其返回值是String类型，返回类名和它 的引用地址。

在进行String与其它类型数据的连接操作时，自动调用toString()方法



## **包装类(Wrapper)的使用**

![image-20220928180348971](E:/typora/image-20220928180348971.png)



![image-20220928181333070](E:/typora/image-20220928181333070.png)

**代码演示：**

```java
        // 包装类的使用
        int i = 5;
        Integer integer = new Integer(i);//把基本数据类型转化为包装类，调用new Integer()
        System.out.println(integer.getClass().getName());//java.lang.Integer

        int i1 = integer.intValue();//包装类转化为基本数据类型，调用包装类的方法：xxxValue()
        System.out.println(i1);//5

        int j = 1;
        String s = String.valueOf(j);// 基本数据类型转化为String类，方式一：调用String.valueOf()
        System.out.println(s.getClass().getName());//java.lang.String

        String s1 = j + ""; // 基本数据类型转化为String类，方式二：+ ""
        System.out.println(s1.getClass().getName());//java.lang.String

        String s2 = "123";
        int i2 = Integer.parseInt(s2); // String类转化为基本数据类型，调用Integer.parseInt()
        System.out.println(i2);//123

        Integer integer1 = new Integer(2);
        String s3 = integer1.toString();// 包装类转化为String类，调用包装类对象的toString()方法
        System.out.println(s3.getClass().getName());//java.lang.String

        Integer i3 = new Integer("456");// String类转化为包装类
        System.out.println(i3.getClass().getName()); //java.lang.Integer
```



## **垃圾回收机制关键点**


垃圾回收机制只回收JVM堆内存里的对象空间。


对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力


现在的JVM有多种垃圾回收实现算法，表现各异。


垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。


可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。


程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有
一些效果，但是系统是否进行垃圾回收依然不确定。


垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一
个新的引用变量重新引用该对象，则会重新激活对象）。

永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。



如果想让一个类的所有实例共享数据，就用类变量！

因为不需要实例就可以访问static方法，因此static方法内部不能有this。(也 不能有super ? YES!)

static修饰的方法不能被重写



## 单例(Singleton)设计模式-饿汉式

```java
class Singleton {
    // 1.私有化构造器
    private Singleton() {
    }
    // 2.内部提供一个当前类的实例
	// 4.此实例也必须静态化
    private static Singleton single = new Singleton();
    // 3.提供公共的静态的方法，返回当前类的对象
    public static Singleton getInstance() {
        return single;
    }
}
```

## 单例(Singleton)设计模式-懒汉式(线程不安全)

```java
class Singleton {
    // 1.私有化构造器
    private Singleton() {
    }
    // 2.内部提供一个当前类的实例
    // 4.此实例也必须静态化
    private static Singleton single;
    // 3.提供公共的静态的方法，返回当前类的对象
    public static Singleton getInstance() {
        if(single == null) {
            single = new Singleton();
        }
        return single;
    }
}
```

## 工厂设计模式

```java
interface Car {
    void run();
}
class Audi implements Car {
    public void run() {
        System.out.println("奥迪在跑");
    }
}
class BYD implements Car {
    public void run() {
        System.out.println("比亚迪在跑");
    }
}
//工厂类
class CarFactory {
    //方式一
    public static Car getCar(String type) {
        if ("奥迪".equals(type)) {
            return new Audi();
        } else if ("比亚迪".equals(type)) {
            return new BYD();
        } else {
            return null;
        }
    }
//方式二
// public static Car getAudi() {
// return new Audi();
// }
//
// public static Car getByd() {
// return new BYD();
// }
}
public class Client02 {
    public static void main(String[] args) {
        Car a = CarFactory.getCar("奥迪");
        a.run();
        Car b = CarFactory.getCar("比亚迪");
        b.run();
    }
}
```

对main方法的语法理解：

```java
public static void main(String[] args) {}
```

由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是 public，又因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须 是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令 时传递给所运行的类的参数。



抽象方法：只有方法的声明，没有方法的实现。以分号结束：

比如：public abstract void talk();



接口(interface)是抽象方法和常量值定义的集合

接口中的所有成员变量都默认是由public static final修饰的。

接口中的所有抽象方法都默认是由public abstract修饰的。



Java 8中，你可以为接口添加静态方法和默认方法。

静态方法：使用 static 关键字修饰。可以通过接口直接调用静态方法，

默认方法：默认方法使用 default 关键字修饰。可以通过实现类对象来调用。

# 异常处理

详情见博客《Java2EE练习及面试题_chapter07异常处理》

# 多线程

##  JDK1.5之前创建新执行线程有两种方法： 

继承Thread类的方式 

1. 定义子类继承Thread类。 
2. 子类中重写Thread类中的run方法。 
3. 创建Thread子类对象，即创建了线程对象。 
4. 调用线程对象start方法：启动线程，调用run方法。

代码演示：

```java
package com.jerry.java;

/**
 * @author jerry_jy
 * @create 2022-10-01 17:33
 */
public class ThreadTest {
    public static void main(String[] args) {
        //3.创建Thread子类对象，即创建了线程对象。
        MyThread myThread = new MyThread();
        //4.调用线程对象start方法：启动线程，调用run方法。
        myThread.start();
    }
}
//1.定义子类继承Thread类。
class MyThread extends Thread {
    public MyThread() {
        super();
    }
// 2.子类中重写Thread类中的run方法。
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("子线程：" + i);
        }
    }
}
```

 注意点： 

1. 如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。 
2. run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU 调度决定。
3. 想要启动多线程，必须调用start方法。 
4. 一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上 的异常“IllegalThreadStateException”。



实现Runnable接口的方式

1) 定义子类，实现Runnable接口。 
2) 子类中重写Runnable接口中的run方法。 
3) 通过Thread类含参构造器创建线程对象。 
4) 将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。 
5) 调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。

代码演示：

```java
package com.jerry.java;

/**
 * @author jerry_jy
 * @create 2022-10-01 17:40
 */
public class RunnableTest {

    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        //3.通过Thread类含参构造器创建线程对象。
        //4.将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。
        Thread thread = new Thread(myRunnable);
        //5.调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。
        thread.start();
    }
}

//1.定义子类，实现Runnable接口。
class MyRunnable implements Runnable{

    //2.子类中重写Runnable接口中的run方法。
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("子线程："+i);
        }
    }
}
```





多线程的创建-->继承方式和实现方式的联系与区别：

区别

​	继承Thread：线程代码存放Thread子类run方法中。

​	实现Runnable：线程代码存在接口的子类的run方法。

 实现方式的好处

​	避免了单继承的局限性

​	多个线程可以共享同一个接口实现类的对象，非常适合多个相同线 程来处理同一份资源。



Thread类的有关方法

```java
void start(): 启动线程，并执行对象的run()方法
run(): 线程在被调度时执行的操作
String getName(): 返回线程的名称
void setName(String name):设置该线程名称
static Thread currentThread(): 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类
static void yield()：线程让步
	暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程
	若队列中没有同优先级的线程，忽略此方法
join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止
    低优先级的线程也可以获得执行
static void sleep(long millis)：(指定时间:毫秒)
	令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。
	抛出InterruptedException异常
stop(): 强制线程生命期结束，不推荐使用
boolean isAlive()：返回boolean，判断线程是否还活着

```

线程的优先级

```java
线程的优先级等级
	MAX_PRIORITY：10 
	MIN _PRIORITY：1 
	NORM_PRIORITY：5 
涉及的方法
	getPriority() ：返回线程优先值
	setPriority(int newPriority) ：改变线程的优先级
说明
    线程创建时继承父线程的优先级
	低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用
```

补充：线程的分类

Java中的线程分为两类：一种是守护线程，一种是用户线程

​	它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开

​	守护线程是用来服务用户线程的，通过在start()方法前调用 thread.setDaemon(true)可以把一个用户线程变成一个守护线程

​	Java垃圾回收就是一个典型的守护线程。

​	若JVM中都是守护线程，当前JVM将退出。

## 线程的生命周期

 JDK中用Thread.State类定义了线程的几种状态

要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类 及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五 种状态：

​	新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建 状态

​	就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已 具备了运行的条件，只是没分配到CPU资源

​	运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线 程的操作和功能

​	阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中 止自己的执行，进入阻塞状态

​	死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束

![image-20221001182136745](E:/typora/image-20221001182136745.png)

![image-20221001182319363](E:/typora/image-20221001182319363.png)

## Synchronized的使用方法

Java对于多线程的安全问题提供了专业的解决方式：同步机制

```java
1. 同步代码块：
synchronized (对象){
// 需要被同步的代码；
}
```

```java
2. synchronized还可以放在方法声明中，表示整个方法为同步方法。
例如：
public synchronized void show (String name){ 
….
}
```

![image-20221001191013849](E:/typora/image-20221001191013849.png)

## 同步机制中的锁

同步锁机制：

在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防 止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法 就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须 锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁 之时，另一个任务就可以锁定并使用它了。

synchronized的锁是什么？

​	任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）

​	同步方法的锁：静态方法（类名.class）、非静态方法（this）

​	同步代码块：自己指定，很多时候也是指定为this或类名.class

## 单例设计模式之懒汉式(线程安全)

```java
package com.jerry.java;

/**
 * @author jerry_jy
 * @create 2022-10-01 19:27
 */
public class SingletonTest {
    //    单例设计模式之懒汉式(线程安全)
    public static void main(String[] args) {
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();
        System.out.println(singleton1 == singleton2);//true
    }
}

class Singleton {
    // 2.内部提供一个当前类Singleton的实例singleton
    // 4.此实例也必须静态化static
    private static Singleton singleton;
    // 1.私有化构造器
    private Singleton() {
    }
    // 3.提供公共的静态的方法getInstance，返回当前类的对象return singleton
    public static Singleton getInstance() {
        if (singleton == null) {
            //synchronized同步监视器：每次只new 一个当前类的对象
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

## Lock(锁)

```java
class A{
    private final ReentrantLock lock = new ReenTrantLock();
    public void m(){
        lock.lock();
        try{
			//保证线程安全的代码;
        }
        finally{
            lock.unlock();
        }
    }
}
```

注意：如果同步代码有异常，要将unlock()写入finally语句块

synchronized 与 Lock 的对比

1. Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是 隐式锁，出了作用域自动释放 

2. Lock只有代码块锁，synchronized有代码块锁和方法锁 
3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有 更好的扩展性（提供更多的子类）

优先使用顺序：

 Lock --> 同步代码块（已经进入了方法体，分配了相应资源）--> 同步方法 （在方法体之外）



## 线程通信

**wait() 与 notify() 和 notifyAll()**

​	wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当 前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。

​	notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待

​	notifyAll ()：唤醒正在排队等待资源的所有线程结束等待.

这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报 java.lang.IllegalMonitorStateException异常。

因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁， 因此这三个方法只能在Object类中声明。

**wait() 方法**

​	在当前线程中调用方法： 对象名.wait()

​	使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify  (或notifyAll) 为止。

​	调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）

​	调用此方法后，当前线程将释放对象监控权 ，然后进入等待

​	在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。

**notify()/notifyAll()**

​	在当前线程中调用方法： 对象名.notify()

​	功能：唤醒等待该对象监控权的一个/所有线程

​	调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）



示例题目：使用两个线程打印 1-100。线程1, 线程2 交替打印

```java
package com.jerry.java;

/**
 * @author jerry_jy
 * @create 2022-10-02 17:26
 */
public class Communication implements Runnable {
    int i = 1;

    @Override
    public void run() {
        while (true) {
            synchronized (this) {
                notify();
                if (i <= 100) {
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "：" + i);
                    i++;

                    try {
                        //使得调用如下wait()方法的线程进入阻塞状态
                        wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                } else {
                    break;
                }
            }
        }
    }

    public static void main(String[] args) {
        Communication communication = new Communication();
        Thread thread1 = new Thread(communication);
        Thread thread2 = new Thread(communication);

        thread1.setName("线程一");
        thread2.setName("线程二");

        thread1.start();
        thread2.start();
    }
}
```



经典例题：生产者/消费者问题

```java
package com.jerry.java;

/**
 * @author jerry_jy
 * @create 2022-10-02 17:45
 */
public class ProductTest {
    /*
    生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处
    取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图
    生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通
    知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如
    果店中有产品了再通知消费者来取走产品。
    这里可能出现两个问题：
    生产者比消费者快时，消费者会漏掉一些数据没有取到。
    消费者比生产者快时，消费者会取相同的数据。
     */
    public static void main(String[] args) {
        Clerk clerk = new Clerk();
        Productor productor = new Productor(clerk);
        Consumer consumer = new Consumer(clerk);
        Thread thread1 = new Thread(productor);
        Thread thread2 = new Thread(consumer);

        thread1.start();
        thread2.start();

    }
}

class Clerk {
    private int product = 0;

    public synchronized void addProduct() {
        if (product > 20) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } else {
            product++;
            System.out.println("生产者生产了第" + product + "个产品");
            notifyAll();
        }
    }

    public synchronized void getProduct() {
        if (product <= 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println("消费者取走了第" + product + "个产品");
            product--;
            notifyAll();
        }
    }

}

class Productor implements Runnable {
    Clerk clerk;

    public Productor(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println("生产者开始生产产品");
        while (true) {
            try {
                Thread.sleep((int) Math.random() * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.addProduct();
        }
    }
}

class Consumer implements Runnable {
    Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep((int) Math.random() * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.getProduct();
        }
    }
}
```



## JDK5.0新增线程创建方式

新增方式一：实现Callable接口

与使用Runnable相比， Callable功能更强大些

​	相比run()方法，可以有返回值

​	方法可以抛出异常

​	支持泛型的返回值

​	需要借助FutureTask类，比如获取返回结果

```java
package com.jerry.java;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * @author jerry_jy
 * @create 2022-10-02 18:46
 */
public class CallableTest {
    public static void main(String[] args) {

        //3.创建Callable接口实现类的对象
        MyCallable myCallable = new MyCallable();
        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask<>(myCallable);
        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
        Thread thread = new Thread(futureTask);
        thread.start();

        //6.获取Callable中call方法的返回值
        //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。
        try {
            Object o = futureTask.get();
            System.out.println("总和为：" + o);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

//1.创建一个实现Callable的实现类
class MyCallable implements Callable {

    //2.实现call方法，将此线程需要执行的操作声明在call()中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            sum += i;
        }
        return sum;
    }
}
```

新增方式二：使用线程池

JDK 5.0起提供了线程池相关API：ExecutorService 和 Executors

```java
package com.jerry.java;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

/**
 * @author jerry_jy
 * @create 2022-10-02 18:54
 */
public class ThreadPool {
    public static void main(String[] args) {
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
        //设置线程池的属性
        System.out.println(service.getClass());//class java.util.concurrent.ThreadPoolExecutor
        service1.setCorePoolSize(15);
        System.out.println(service1.getMaximumPoolSize());//10

        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
        service.execute(new NumberThread());//适合适用于Runnable
        service.execute(new NumberThread1());//适合适用于Runnable

        //3.关闭连接池
        service.shutdown();
    }
}

class NumberThread implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i <= 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

class NumberThread1 implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i <= 100; i++) {
            if (i % 2 != 0) {
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}
```

# Java常用类

## 字符串相关的类

String的特性

- ​	String是一个final类，代表不可变的字符序列。

- ​	字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。

- ​	String对象的字符内容是存储在一个字符数组value[]中的。


String str1 = “abc”;与String str2 = new String(“abc”);的区别？

​	String str1 = “abc”;字符串常量存储在 字符串常量池，目的是共享

​	String str2 = new String(“abc”);字符串非常量对象存储在堆中

字符串对象是如何存储的？

- ​	常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。

- ​	只要其中有一个是变量，结果就在堆中

- ​	如果拼接的结果调用intern()方法，返回值就在常量池中


![image-20221003105527446](E:/typora/image-20221003105527446.png)

String常用方法

```java
int length()：返回字符串的长度： return value.length
char charAt(int index)： 返回某索引处的字符return value[index]
boolean isEmpty()：判断是否是空字符串：return value.length == 0
String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写
String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写
String trim()：返回字符串的副本，忽略前导空白和尾部空白
boolean equals(Object obj)：比较字符串的内容是否相同
boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写
String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”
int compareTo(String anotherString)：比较两个字符串的大小
String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。
String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。
boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束
boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始
boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始
boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true
int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引
int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始
int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引
int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索
注：indexOf和lastIndexOf方法如果未找到都是返回-1
String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。
String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。
String replaceAll(String regex, String replacement) ： 使 用 给 定 的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。
String replaceFirst(String regex, String replacement) ： 使 用 给 定 的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。
boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。
String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。
String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中
```

StringBuffer类

java.lang.StringBuffer代表<font color="red" size="4">可变的字符序列</font>，JDK1.0中声明，可以对字符 串内容进行增删，此时不会产生新的对象。

StringBuffer类不同于String，其对象必须使用构造器生成。有三个构造器：

- ​	StringBuffer()：初始容量为16的字符串缓冲区

- ​	StringBuffer(int size)：构造指定容量的字符串缓冲区

- ​	StringBuffer(String str)：将内容初始化为指定字符串内容


StringBuffer类的常用方法

```java
StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接
StringBuffer delete(int start,int end)：删除指定位置的内容
StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str
StringBuffer insert(int offset, xxx)：在指定位置插入xxx
StringBuffer reverse() ：把当前字符序列逆转
public int indexOf(String str)
public String substring(int start,int end)
public int length()
public char charAt(int n )
public void setCharAt(int n ,char ch)
```

当append和insert时，如果原来value数组长度不够，可扩容



StringBuilder类

- ​	StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且 提供相关功能的方法也一样


面试题：对比String、StringBuffer、StringBuilder

- ​	String(JDK1.0)：不可变字符序列

- ​	StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全

- ​	<font color="red" size="4">StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全</font>


注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder 会改变其值。

测试三者的效率：

```java
    /*
    对比String、StringBuffer、StringBuilder三者的效率：
    从高到低排列：StringBuilder > StringBuffer > String
     */
public class StringBuilderTest {
    public static void main(String[] args) {
        long startTime = 0L;
        long endTime = 0L;
        StringBuffer buffer = new StringBuffer("");
        StringBuilder builder = new StringBuilder("");
        String str = "";

        //StringBuffer的执行时间
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 20000; i++) {
            buffer.append(String.valueOf(i));
        }
        endTime = System.currentTimeMillis();
        System.out.println("StringBuffer的执行时间：" + (endTime - startTime));//StringBuffer的执行时间：3

        //StringBuilder的执行时间
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 20000; i++) {
            builder.append(String.valueOf(i));
        }
        endTime = System.currentTimeMillis();
        System.out.println("StringBuilder的执行时间：" + (endTime - startTime));//StringBuilder的执行时间：3

        //String的测试时间
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 20000; i++) {
            str = str + i;
        }
        endTime = System.currentTimeMillis();
        System.out.println("String的测试时间：" + (endTime - startTime));//String的测试时间：908
    }
}    

```

```java
String、StringBuffer、StringBuilder三者的异同？
	String:不可变的字符序列；底层使用char[]存储
    StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储
    StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储

    源码分析：
    String str = new String();//char[] value = new char[0];
    String str1 = new String("abc");//char[] value = new char[]{'a','b','c'};

    StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。
    System.out.println(sb1.length());//
    sb1.append('a');//value[0] = 'a';
    sb1.append('b');//value[1] = 'b';

    StringBuffer sb2 = new StringBuffer("abc");//char[] value = new char["abc".length() + 16];

    //问题1. System.out.println(sb2.length());//3
    //问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。
             默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。

            指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)

```



## 日期时间API

java.util.Date类 表示特定的瞬间，精确到毫秒

- ​	Date()：使用无参构造器创建的对象可以获取本地当前时间

- ​	getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象 表示的毫秒数。


```java
    @Test
    public void test2() {
        Date date = new Date();
        System.out.println(date);//Mon Oct 03 20:44:17 CST 2022
        System.out.println(date.getTime());//返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数1664804213645
        System.out.println(date.getMonth());//9
    }
```

java.text.SimpleDateFormat类

- ​	Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat 类是一个不与语言环境有关的方式来格式化和解析日期的具体类




```java
    @Test
    public void test3() {
        //日期-->文本的格式化
        // 产生一个Date实例
        Date date = new Date();
        // 产生一个 simpleDateFormat 格式化的实例
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat();
        System.out.println(simpleDateFormat.format(date));//22-10-3 下午9:41
        SimpleDateFormat simpleDateFormat1 = new SimpleDateFormat("yyyy年MM月dd日 EEE HH:mm:ss");
        System.out.println(simpleDateFormat1.format(date));//2022年10月03日 星期一 21:42:58

        //文本-->日期的格式化
        try {
            // 实例化一个指定的格式对象
            Date date1 = simpleDateFormat1.parse("2008年08月08日 星期一 08:08:08");
            // 将指定的日期解析后格式化按指定的格式输出
            System.out.println(date1);//Fri Aug 08 08:08:08 CST 2008
        } catch (ParseException e) {
            e.printStackTrace();
        }

    }
```

java.util.Calendar(日历)类

​	Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能

​	获取Calendar实例的方法

- ​		使用Calendar.getInstance()方法

- ​		调用它的子类GregorianCalendar的构造器


## Java比较器（对象比较排序）

Java实现对象排序的方式有两种：

1	自然排序：java.lang.Comparable

Comparable 的典型实现：(默认都是从小到大排列的)

- ​	String：按照字符串中字符的Unicode值进行比较

- ​	Character：按照字符的Unicode值来进行比较

- ​	数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值 大小进行比较

- ​	Boolean：true 对应的包装类实例大于 false 对应的包装类实例

- ​	Date、Time等：后面的日期时间比前面的日期时间大


```java
package com.jerry.java;

import org.junit.Test;

import java.util.Arrays;
import java.util.Comparator;

/**
 * @author jerry_jy
 * @create 2022-10-04 8:53
 */
public class ComparableTest {
    public static void main(String[] args) {
        Goods[] all = new Goods[4];
        all[0] = new Goods("《红楼梦》", 100);
        all[1] = new Goods("《西游记》", 80);
        all[2] = new Goods("《三国演义》", 140);
        all[3] = new Goods("《水浒传》", 120);

        Arrays.sort(all);
        System.out.println(Arrays.toString(all));
    }

}

class Goods implements Comparable {
    private String name;
    private double price;

    public Goods() {
    }

    public Goods(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Goods{" +
                "name='" + name + '\'' +
                ", price=" + price +
                '}';
    }

    //指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序
    @Override
    public int compareTo(Object o) {
        if (o instanceof Goods) {
            Goods goods = (Goods) o;
//            if (this.price > goods.price) {
//                return 1;
//            } else if (this.price < goods.getPrice()) {
//                return -1;
//            }else {
//                return 0;
//            }
            //方式二：
           return Double.compare(this.price,goods.price);
        }
        throw new RuntimeException("传入的数据类型不一致！");
    }
}
```

2	定制排序：java.util.Comparator

当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码， 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那 么可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排 序的比较。

重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返 回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示 o1小于o2。

可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort）， 从而允许在排序顺序上实现精确控制。

还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的 顺序，或者为那些没有自然顺序的对象 collection 提供排序。

```java
    @Test
    public void test1(){
        Goods[] all = new Goods[4];
        all[0] = new Goods("War and Peace", 100);
        all[1] = new Goods("Childhood", 80);
        all[2] = new Goods("Scarlet and Black", 140);
        all[3] = new Goods("Notre Dame de Paris", 120);

        Arrays.sort(all,new Comparator(){

            @Override
            public int compare(Object o1, Object o2) {
                Goods goods1 = (Goods) o1;
                Goods goods2 = (Goods) o2;
                return goods1.getName().compareTo(goods2.getName());
            }
        });
        System.out.println(Arrays.toString(all));
    }
```

## System类

```java
package com.jerry.java;

import sun.plugin2.os.windows.Windows;

/**
 * @author jerry_jy
 * @create 2022-10-04 10:20
 */
public class SystemTest {
    public static void main(String[] args) {
        String javaVersion = System.getProperty("java.version");
        System.out.println("java的version:" + javaVersion);//java的version:1.8.0_301
        String javaHome = System.getProperty("java.home");//java的home:E:\Java_tools\jdk1.8.0_301\jre
        System.out.println("java的home:" + javaHome);
        String osName = System.getProperty("os.name");
        System.out.println("os的name:" + osName);//os的name:Windows 10
        String osVersion = System.getProperty("os.version");
        System.out.println("os的version:" + osVersion);//os的version:10.0
        String userName = System.getProperty("user.name");
        System.out.println("user的name:" + userName);//user的name:Admin
        String userHome = System.getProperty("user.home");
        System.out.println("user的home:" + userHome);//user的home:C:\Users\15718
        String userDir = System.getProperty("user.dir");
        System.out.println("user的dir:" + userDir);//user的dir:E:\CodeLife\IdeaProject\JVM

    }
}
```

# 枚举类与注解

枚举类的属性

- ​	枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰

- ​	枚举类的使用 private final 修饰的属性应该在构造器中为其赋值

- ​	若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的 传入参数


## 自定义枚举类代码演示：

```java
package com.jerry.java;

/**
 * @author jerry_jy
 * @create 2022-10-05 9:11
 */
public class SeasonTest {
    public static void main(String[] args) {
        Season spring = Season.SPRING;
        System.out.println(spring);
    }
}

//自定义枚举类
class Season {
    //1.声明Season对象的属性:private final修饰
    private final String seasonName;
    private final String seasonDesc;

    //2.私有化类的构造器,并给对象属性赋值
    private Season(String seasonName, String seasonDesc) {
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }

    //3.提供当前枚举类的多个对象：public static final的
    public static final Season SPRING = new Season("春天", "春暖花开");
    public static final Season SUMMER = new Season("夏天", "夏日炎炎");
    public static final Season AUTUMN = new Season("秋天", "秋高气爽");
    public static final Season WINTER = new Season("冬天", "冰天雪地");

    //4.其他诉求1：获取枚举类对象的属性
    public String getSeasonName() {
        return seasonName;
    }

    public String getSeasonDesc() {
        return seasonDesc;
    }

    //4.其他诉求1：提供toString()
    @Override
    public String toString() {
        return "Season{" +
                "seasonName='" + seasonName + '\'' +
                ", seasonDesc='" + seasonDesc + '\'' +
                '}';
    }
}
```

## 使用enum定义枚举类

​	使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再 继承其他类

​	枚举类的构造器只能使用 private 权限修饰符

​	枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾)。列出的 实例系统会自动添加 public static final 修饰

​	必须在枚举类的第一行声明枚举类对象

```java
package com.jerry.java;

/**
 * @author jerry_jy
 * @create 2022-10-05 9:25
 */
public enum SeasonEnum {
    SPRING("春天", "春风又绿江南岸"),
    SUMMER("夏天", "映日荷花别样红"),
    AUTUMN("秋天", "秋水共长天一色"),
    WINTER("冬天", "窗含西岭千秋雪");
    private final String seasonName;
    private final String seasonDesc;

    private SeasonEnum(String seasonName, String seasonDesc) {
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }

    public String getSeasonName() {
        return seasonName;
    }

    public String getSeasonDesc() {
        return seasonDesc;
    }
}
```

​	

Enum类的主要方法：

- ​	values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的 枚举值。

- ​	valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符 串必须是枚举类对象的“名字”。如不是，会有运行时异常： IllegalArgumentException。

- ​	toString()：返回当前枚举类对象常量的名称


代码演示：

```java
package com.jerry.java;

/**
 * @author jerry_jy
 * @create 2022-10-05 9:31
 */
public class SeasonTest1 {
    public static void main(String[] args) {
        Season1 summer = Season1.SUMMER;
        System.out.println(summer.toString());//Season1{seasonName='夏天', seasonDesc='夏日炎炎'}

        System.out.println(Season1.AUTUMN.getSeasonName());//秋天
        System.out.println(Season1.WINTER.getSeasonDesc());//冰天雪地

        System.out.println(Season1.class.getSuperclass());//class java.lang.Enum
        System.out.println("****************");
        //values():返回所有的枚举类对象构成的数组
        Season1[] values = Season1.values();
        for (int i = 0; i < values.length; i++) {
            System.out.println(values[i]);
            values[i].show();
        }
        System.out.println("****************");
        Thread.State[] values1 = Thread.State.values();
        for (int i = 0; i < values1.length; i++) {
            System.out.println(values1[i]);
        }
        //valueOf(String objName):返回枚举类中对象名是objName的对象。
        Season1 spring = Season1.valueOf("SPRING");
        spring.show();//春天在哪里？
        System.out.println(spring);//Season1{seasonName='春天', seasonDesc='春暖花开'}
        System.out.println(Season1.valueOf("WINTER1"));//Exception in thread "main" java.lang.IllegalArgumentException: No enum constant com.jerry.java.Season1.WINTER1

    }
}

interface info {
    void show();
}

enum Season1 implements info {
    SPRING("春天", "春暖花开") {
        @Override
        public void show() {
            System.out.println("春天在哪里？");
        }
    }, SUMMER("夏天", "夏日炎炎") {
        @Override
        public void show() {
            System.out.println("宁夏");
        }
    }, AUTUMN("秋天", "秋高气爽") {
        @Override
        public void show() {
            System.out.println("秋天不回来");
        }
    }, WINTER("冬天", "冰天雪地") {
        @Override
        public void show() {
            System.out.println("大约在冬季");
        }
    };


    private final String seasonName;
    private final String seasonDesc;

    private Season1(String seasonName, String seasonDesc) {
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }

    public String getSeasonName() {
        return seasonName;
    }

    public String getSeasonDesc() {
        return seasonDesc;
    }

    @Override
    public String toString() {
        return "Season1{" +
                "seasonName='" + seasonName + '\'' +
                ", seasonDesc='" + seasonDesc + '\'' +
                '}';
    }
}
```

## 注解(Annotation)

在编译时进行格式检查(JDK内置的三个基本注解)

​	@Override: 限定重写父类方法, 该注解只能用于方法

​	@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择

​	@SuppressWarnings: 抑制编译器警告

```java
package com.jerry.exer;

/**
 * @author jerry_jy
 * @create 2022-10-05 11:15
 */
public class Exer6 {
    /*
    定义一个Student类，要求重写toString()的方法，并且此方法要使用Annotation的三个基本的注释，创建Test类，输出Student类的toString方法的所有注释
     */
    public static void main(String[] args) {

        Student jerry = new Student(123, "jerry");
        System.out.println(jerry.toString());
        jerry.print();
    }
}

class Student {
    int StuID;
    String name;

    public Student(int stuID, String name) {
        StuID = stuID;
        this.name = name;
    }

    @Override
    public String toString() {
        return "重写的toString方法()";
    }

    @Deprecated
    public void print() {
        System.out.println("过时的方法");

        @SuppressWarnings("unused")
        int a = 1000;
        a=1;
        System.out.println("a= " + a);
    }
}
```



自定义Annotation

```java
package com.jerry.exer;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author jerry_jy
 * @create 2022-10-05 11:11
 */

@MyAnnotation("tom")
public class Exer5 {
    /*
    自定义annotation，里面包括1个String类型的属性，一个有默认值类型的属性，使用自定义的annotation
     */
    public static void main(String[] args) {
        System.out.println(Exer5.class.getAnnotation(MyAnnotation.class).value());//tom
    }
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface MyAnnotation {
    String value() default "jerry";
}
```



# Java 集合框架

Java 集合可分为 Collection 和 Map 两种体系

​	Collection接口：单列数据，定义了存取一组对象的方法的集合

- ​		List：元素有序、可重复的集合

- ​		Set：元素无序、不可重复的集合


![image-20221005164610384](E:/typora/image-20221005164610384.png)

​	

##  Collection 接口方法

```java
1、添加
add(Object obj)
addAll(Collection coll)
2、获取有效元素的个数
int size()
3、清空集合
void clear()
4、是否是空集合
boolean isEmpty()
5、是否包含某个元素
boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象
boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。
6、删除
boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素
boolean removeAll(Collection coll)：取当前集合的差集
7、取两个集合的交集
boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c
8、集合是否相等
boolean equals(Object obj)
9、转成对象数组
Object[] toArray()
10、获取集合对象的哈希值
hashCode()
11、遍历
iterator()：返回迭代器对象，用于集合遍历
```



### Collection子接口之一：List接口

- ​	List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。

- ​	JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。


#### List实现类之一：ArrayList

ArrayList 是 List 接口的典型实现类、主要实现类

本质上，ArrayList是对象引用的一个”变长”数组

<font color="blue" size="4">ArrayList的JDK1.8之前与之后的实现区别？</font>

- ​	JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组

- ​	JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元 素时再创建一个始容量为10的数组


Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合

#### List实现类之二：LinkedList

对于<font color="blue" size="4">频繁的插入或删除元素的操作</font>，建议使用LinkedList类，效率较高

新增方法：

```java
void addFirst(Object obj)
void addFirst(Object obj)
Object getFirst()
Object getLast()
Object removeFirst()
Object removeLast()
```

代码演示：

```java
    @Test
    public void test3(){
        LinkedList linkedList = new LinkedList();
        linkedList.add("AA");
        linkedList.add("BB");
        linkedList.add("CC");
        linkedList.addFirst("first");
        linkedList.addLast("last");
        System.out.println(linkedList);//[first, AA, BB, CC, last]
        System.out.println(linkedList.getFirst());//first
        System.out.println(linkedList.getLast());//last
        linkedList.removeFirst();
        linkedList.removeLast();
        System.out.println(linkedList);//[AA, BB, CC]
    }
}
```

内部结构：

LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last， 用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基 本结构。Node除了保存数据，还定义了两个变量：

prev变量记录前一个元素的位置

next变量记录下一个元素的位置



#### List 实现类之三：Vector

Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList 相同，区别之处在于<font color="blue" size="4">Vector是线程安全的。</font>

在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时， 使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。

新增方法：

```java
void addElement(Object obj)
void insertElementAt(Object obj,int index)
void setElementAt(Object obj,int index)
void removeElement(Object obj)
void removeAllElements()
```

面试题：

```java
请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?
1、ArrayList和LinkedList的异同
二者都线程不安全，相对线程安全的Vector，执行效率高。
此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。
2、ArrayList和Vector的区别
Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。
```

### Collection子接口之二：Set接口

Set接口是Collection的子接口，set接口没有提供额外的方法 

Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。 

Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法

#### Set实现类之一：HashSet

HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。

HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除 性能。

HashSet 具有以下特点：

- ​	不能保证元素的排列顺序 

- ​	HashSet 不是线程安全的

- ​	集合元素可以是 null


HashSet 集合判断两个元素相等的标准：<font color="red" size="4">两个对象通过 hashCode() 方法比较相 等，并且两个对象的 equals() 方法返回值也相等。</font>

对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object  obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。



向HashSet中添加元素的过程：

当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法 来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象 在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在 数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布， 该散列函数设计的越好）

如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果 为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了， 那么会通过链表的方式继续链接

如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相 等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。

底层也是数组，<font color="red" size="4">初始容量为16，当如果使用率超过0.75，（16*0.75=12） 就会扩大容量为原来的2倍。</font>（16扩容为32，依次为64,128....等）



重写 hashCode() 方法的基本原则

在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。 

当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode()  方法的返回值也应相等。 

对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。



重写 equals() 方法的基本原则

当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是 要改写hashCode()，根据一个类的equals方法（改写后），两个截然不 同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法， 它们仅仅是两个对象。

因此，违反了“相等的对象必须具有相等的散列码”。

结论：复写equals方法的时候一般都需要同时复写hashCode方法。通 常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。



问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？

选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的 “冲突”就越少，查找起来效率也会提高。（减少冲突）

并且31只占用5bits,相乘造成数据溢出的概率较小。

31可以 由i*31== (i<<5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效 率）

31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结 果只能被素数本身和被乘数还有1来整除！(减少冲突)



使用HashSet去除List中的重复元素

```java
    @Test
    public void test4() {
        List list = new ArrayList();
        list.add(new Integer(1));
        list.add(new Integer(2));
        list.add(new Integer(2));
        list.add(new Integer(4));
        list.add(new Integer(4));
        List list2 = duplicateList(list);
        for (Object integer : list2) {
            System.out.println(integer);
        }
    }

    public static List duplicateList(List list) {
        //在List内去除重复数字值，要求尽量简单
        HashSet set = new HashSet();
        set.addAll(list);//把List内含有重复数字值的集合，添加到HashSet里，自动就去重了
        return new ArrayList(set);//把新的集合set传到ArrayList里面
    }
```



#### Set实现类之二：LinkedHashSet

LinkedHashSet 是 HashSet 的子类

LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置， 但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入 顺序保存的。

LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全 部元素时有很好的性能。

LinkedHashSet 不允许集合元素重复。

#### Set实现类之三：TreeSet

TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。

TreeSet底层使用红黑树结构存储数据 

新增的方法如下： (了解)

```java
Comparator comparator()
Object first()
Object last()
Object lower(Object e)
Object higher(Object e)
SortedSet subSet(fromElement, toElement)
SortedSet headSet(toElement)
SortedSet tailSet(fromElement)
```

TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。

自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元 素之间的大小关系，然后将集合元素按升序(默认情况)排列 

如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable  接口。

- ​	实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。


## Iterator迭代器接口

Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。

集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合 的第一个元素之前。

Iterator包含的方法：

![image-20221005174843528](E:/typora/image-20221005174843528.png)

在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且 下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。

```java
        System.out.println("=========iterator==========");
        Iterator iterator = vector.iterator();
        while (iterator.hasNext()){
            Object o = iterator.next();
            if (o.equals(789)){
                iterator.remove();
            }
            System.out.println(iterator.next());//DD 789
        }
```

注意：

Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方 法，不是集合对象的remove方法。

如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法， 再调用remove都会报IllegalStateException。



使用 foreach 循环遍历集合元素

- ​	Java 5.0 提供了 foreach 循环迭代访问 Collection和数组。

- ​	遍历操作不需获取Collection或数组的长度，无需使用索引访问元素

- ​	遍历集合的底层调用Iterator完成操作。


​	



## Map接口：

双列数据，保存具有映射关系“key-value对”的集合

![image-20221005164726293](E:/typora/image-20221005164726293.png)

Map接口：常用方法

```java
    @Test
    public void test5() {
        HashMap hashMap = new HashMap();
        hashMap.put(001, "AA");
        hashMap.put(002, "BB");
        hashMap.put(003, "CC");

        System.out.println(hashMap.size());//3
        System.out.println("map的所有的value：");
        Collection values = hashMap.values();
        Iterator iterator = values.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
        System.out.println("map的所有key:");
        Set keys = hashMap.keySet();
        for (Object key : keys) {
            System.out.println(key + "->" + hashMap.get(key));
        }
        System.out.println("map所有的映射关系：");
        // 映射关系的类型是Map.Entry类型，它是Map接口的内部接口
        Set mappings = hashMap.entrySet();
        for (Object mapping : mappings) {
            Map.Entry entry = (Map.Entry) mapping;
            System.out.println("key是：" + entry.getKey() + "，value是：" + entry.getValue());
        }
    }
```

### Map实现类之一：HashMap

是 Map 接口使用频率最高的实现类。

允许使用null键和null值，与HashSet一样，不保证映射的顺序。 

所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写： equals()和hashCode() 

所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的类 要重写：equals() 

一个key-value构成一个entry 

所有的entry构成的集合是Set:无序的、不可重复的 

HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true， hashCode 值也相等。 HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。



**HashMap的存储结构：**

JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法) 

JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。



**HashMap的存储结构：JDK 1.8之前**

HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时， 系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量 (Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个 bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。 

每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引 用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。 而且新添加的元素作为链表的head。 

添加元素的过程： 

向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据 key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数 组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上 已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次 比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果 hash值不同，继续比较二者是否equals。如果返回值为true，则使用entry1的value 去替换equals为true的entry的value。如果遍历一遍以后，发现所有的equals返回都 为false,则entry1仍可添加成功。entry1指向原有的entry元素。

HashMap的扩容 

当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的 长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在 HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算 其在新数组中的位置，并放进去，这就是resize。

那么HashMap什么时候进行扩容呢？ 

当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数 size)*loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的默认 值 (DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况 下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数 超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把 数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置， 而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数， 那么预设元素的个数能够有效的提高HashMap的性能



**HashMap的存储结构：JDK 1.8**

HashMap的内部存储结构其实是数组+链表+树的结合。当实例化一个 HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系 时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表 中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为 “桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查 找bucket中的元素。 

每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带 一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能 生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象 可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个 TreeNode树。而新添加的元素作为链表的last，或树的叶子结点



那么HashMap什么时候进行扩容和树形化呢？ 

当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数 size)*loadFactor 时 ， 就会进行数组扩容 ， loadFactor 的默认 值 (DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认 情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中 元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值） 的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元 素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。 

当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有 达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成 树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后， 下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。



关于映射关系的key是否可以修改？answer：不要修改 

映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算 每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关 系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。



**总结：**JDK1.8相较于之前的变化： 

1.HashMap map = new HashMap();//默认情况下，先不创建长度为16的数组 

2.当首次调用map.put()时，再创建长度为16的数组 

3.数组为Node类型，在jdk7中称为Entry类型 

4.形成链表结构时，新添加的key-value对在链表的尾部（七上八下） 

5.当数组指定索引位置的链表长度>8时，且map中的数组的长度> 64时，此索引位置 上的所有key-value对使用红黑树进行存储



HashMap源码中的重要常量

```java
DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
MAXIMUM_CAPACITY ： HashMap的最大支持容量，2^30
DEFAULT_LOAD_FACTOR：HashMap的默认加载因子
TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树
UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表
MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量。（当桶中Node的
数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行
resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4
倍。）
table：存储元素的数组，总是2的n次幂
entrySet：存储具体元素的集
size：HashMap中存储的键值对的数量
modCount：HashMap扩容和结构改变的次数。
threshold：扩容的临界值，=容量*填充因子
loadFactor：填充因子
```



面试题： 谈谈你对HashMap中put/get方法的认识？如果了解再谈谈 HashMap的扩容机制？默认大小是多少？什么是负载因子( 或填充比)？什么是吞吐临界值(或阈值、threshold)？



面试题：负载因子值的大小，对HashMap有什么影响

负载因子的大小决定了HashMap的数据密度。 

负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。 

负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的 几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性 能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建 议初始化预设大一点的空间。 

按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此 时平均检索长度接近于常数。

### Map实现类之二：LinkedHashMap

LinkedHashMap 是 HashMap 的子类 

在HashMap存储结构的基础上，使用了一对双向链表来记录添加 元素的顺序 

与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代 顺序：迭代顺序与 Key-Value 对的插入顺序一致



HashMap中的内部类：Node

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
}
```

LinkedHashMap中的内部类：Entry

```java
static class Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after;
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}
```

### Map实现类之三：TreeMap

TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。 TreeMap 可以保证所有的 Key-Value 对处于有序状态。 

TreeSet底层使用红黑树结构存储数据 

TreeMap 的 Key 的排序： 

​	自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有 的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException 

​	定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口 

TreeMap判断两个key相等的标准：两个key通过compareTo()方法或 者compare()方法返回0。

### Map实现类之四：Hashtable

Hashtable是个古老的 Map 实现类，JDK1.0就提供了。不同于HashMap， Hashtable是线程安全的。 

Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询 速度快，很多情况下可以互用。 <font color="blue" size="4">与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value </font>

与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序 

Hashtable判断两个key相等、两个value相等的标准，与HashMap一致



### Map实现类之五：Properties

Properties 类是 Hashtable 的子类，该对象用于处理属性文件 

由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key  和 value 都是字符串类型 

存取数据时，建议使用setProperty(String key,String value)方法和 getProperty(String key)方法

## Collections工具类

Collections 是一个操作 Set、List 和 Map 等集合的工具类 

Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作， 还提供了对集合对象设置不可变、对集合对象实现同步控制等方法

```java
排序操作：（均为static方法）
reverse(List)：反转 List 中元素的顺序
shuffle(List)：对 List 集合元素进行随机排序
sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序
sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换查找、替换
Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素
Object min(Collection)
Object min(Collection，Comparator)
int frequency(Collection，Object)：返回指定集合中指定元素的出现次数
void copy(List dest,List src)：将src中的内容复制到dest中
boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值
```

代码演示：

```java
package com.jerry.java;

import java.util.*;

/**
 * @author jerry_jy
 * @create 2022-10-06 9:51
 */
public class CollectionsTest {
    public static void main(String[] args) {
        ArrayList arrayList = new ArrayList();
        arrayList.add("AA");
        arrayList.add("BB");
        arrayList.add("11");
        arrayList.add("22");
        System.out.println("========原始集合========");
        System.out.println(arrayList);//[AA, BB, 11, 22]
        System.out.println("========swap========");
        Collections.swap(arrayList, 0, 2);
        System.out.println(arrayList);//[11, BB, AA, 22]
        System.out.println("========sort按升序排序========");
        Collections.sort(arrayList);
        System.out.println(arrayList);//[11, 22, AA, BB]
        System.out.println("========shuffle随机排序========");
        Collections.shuffle(arrayList);
        System.out.println(arrayList);//[11, BB, AA, 22]
        System.out.println("========reverse========");
        Collections.reverse(arrayList);
        System.out.println(arrayList);//[22, 11, BB, AA]
        System.out.println("========max========");
        Comparable max = Collections.max(arrayList);
        System.out.println(max);
        System.out.println("========min========");
        Comparable min = Collections.min(arrayList);
        System.out.println(min);
        System.out.println("========frequency========");
        int frequency = Collections.frequency(arrayList, "AA");
        System.out.println(frequency);
    }
}
```

# 泛型(Generic)

允许在定义类、接口时通过一个标识表示类中某个属性的类 型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如， 继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实 际的类型参数，也称为类型实参）。

使用泛型的主要优点是能够在编译时而不是在运行时检测错误

在List集合中使用泛型

```java
        ArrayList<Integer> list = new ArrayList<>();//类型推断
        list.add(78);
        list.add(88);
        list.add(77);
        list.add(66);
        //遍历方式一：
        for (Integer integer : list) {
            //不需要强转
            System.out.println(integer);
        }
        System.out.println();
        //遍历方式二：
        Iterator<Integer> iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
```

在Map集合中使用泛型

```java
        HashMap<String, Integer> map = new HashMap<>();
        map.put("Tom1",34);
        map.put("Tom2",44);
        map.put("Tom3",33);
        map.put("Tom4",32);

        Set<Map.Entry<String, Integer>> entrySet = map.entrySet();
        Iterator<Map.Entry<String, Integer>> iterator = entrySet.iterator();
        while (iterator.hasNext()){
            Map.Entry<String, Integer> entry = iterator.next();
            System.out.println(entry.getKey() + "--->" + entry.getValue());
        }
```

##  自定义泛型结构

```java
1. 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如： <E1,E2,E3>

2. 泛型类的构造器如下：public GenericClass(){}。 而下面是错误的：public GenericClass<E>(){}
3. 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。 
4. 泛型不同的引用不能相互赋值。 尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有 一个ArrayList被加载到JVM中。 
5. 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价 于Object。经验：泛型要使用一路都用。要不用，一路都不要用。 
6. 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。 
7. jdk1.7，泛型的简化操作：ArrayList flist = new ArrayList<>(); 
8. 泛型的指定中不能使用基本数据类型，可以使用包装类替换。
9. 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。
10. 异常类不能是泛型的
11. 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];
参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。
12.父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：
	子类不保留父类的泛型：按需实现
		没有类型 擦除
		具体类型
	子类保留父类的泛型：泛型子类
		全部保留
		部分保留
结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型    
```

```java
class Father<T1, T2> {
}
// 子类不保留父类的泛型
// 1)没有类型 擦除
class Son1 extends Father {// 等价于class Son extends Father<Object,Object>{
}
// 2)具体类型
class Son2 extends Father<Integer, String> {
}
// 子类保留父类的泛型
// 1)全部保留
class Son3<T1, T2> extends Father<T1, T2> {
}
// 2)部分保留
class Son4<T2> extends Father<Integer, T2> {
}
```





### 泛型类

```java
class Person<T>{
    private T info;

    public T getInfo() {
        return info;
    }

    public void setInfo(T info) {
        this.info = info;
    }

    public Person() {
    }

    public Person(T info) {
        this.info = info;
    }
}
```

### 泛型方法

泛型方法的格式：

[访问权限] <泛型> 返回类型 方法名([泛型标识 参数名称]) 抛出的异常



 泛型在继承上的体现

```java
如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G<B>并不是G<A>的子类型！
比如：String是Object的子类，但是List<String>并不是List<Object>的子类。
```

## 通配符的使用



```java
1.使用类型通配符：？
比如：List<?> ，Map<?,?>
List<?>是List<String>、List<Object>等各种泛型List的父类。
2.读取List<?>的对象list中的元素时，永远是安全的，因为不管list的真实类型是什么，它包含的都是Object。
3.写入list中的元素时，不行。因为我们不知道c的元素类型，我们不能向其中添加对象。
	唯一的例外是null，它是所有类型的成员。

```

通配符的使用：注意点

```java
//注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面<>不能使用?
public static <?> void test(ArrayList<?> list){}
//注意点2：编译错误：不能用在泛型类的声明上
class GenericTypeClass<?>{}
//注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象
ArrayList<?> list2 = new ArrayList<?>();
```

### 有限制的通配符

![image-20221007185126094](E:/typora/image-20221007185126094.png)



## 泛型嵌套

```java
public static void main(String[] args) {
    HashMap<String, ArrayList<Citizen>> map = new HashMap<String, ArrayList<Citizen>>();
    ArrayList<Citizen> list = new ArrayList<Citizen>();
    list.add(new Citizen("刘恺威"));
    list.add(new Citizen("杨幂"));
    list.add(new Citizen("小糯米"));
    map.put("刘恺威", list);
    Set<Entry<String, ArrayList<Citizen>>> entrySet = map.entrySet();
    Iterator<Entry<String, ArrayList<Citizen>>> iterator = entrySet.iterator();
    while (iterator.hasNext()) {
        Entry<String, ArrayList<Citizen>> entry = iterator.next();
        String key = entry.getKey();
        ArrayList<Citizen> value = entry.getValue();
        System.out.println("户主：" + key);
        System.out.println("家庭成员：" + value);
    }
}
```

# IO流(Input/Output)

 寓为“开放中创新”(Innovation in the Open)

## File类

public File(String pathname) 以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果 pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。 

- ​	绝对路径：是一个固定的路径,从盘符开始 

- ​	相对路径：是相对于某个位置开始



```java
    说明：如果使用单元测试，文件相对路径为当前module
          如果使用main()测试，文件相对路径为当前工程
```




路径分隔符

路径中的每级目录之间用一个路径分隔符隔开。

路径分隔符和系统有关：

- ​	windows和DOS系统默认使用“\”来表示

- ​	UNIX和URL使用“/”来表示


Java程序支持跨平台运行，因此路径分隔符要慎用

为了解决这个隐患，File类提供了一个常量： public static final String separator。根据操作系统，动态的提供分隔符



File 类的使用：常用方法

```java
File类的获取功能
public String getAbsolutePath()：获取绝对路径
public String getPath() ：获取路径
public String getName() ：获取名称
public String getParent()：获取上层文件目录路径。若无，返回null
public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。
public long lastModified() ：获取最后一次的修改时间，毫秒值
public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组
public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组
File类的重命名功能
public boolean renameTo(File dest):把文件重命名为指定的文件路径
File类的判断功能
public boolean isDirectory()：判断是否是文件目录
public boolean isFile() ：判断是否是文件
public boolean exists() ：判断是否存在
public boolean canRead() ：判断是否可读
public boolean canWrite() ：判断是否可写
public boolean isHidden() ：判断是否隐藏    
File类的创建功能
public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false
public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。
如果此文件目录的上层目录不存在，也不创建。
public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建
注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下。
File类的删除功能
public boolean delete()：删除文件或者文件夹
删除注意事项：
	Java中的删除不走回收站。
	要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录    
如下的两个方法适用于文件目录：
public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组
public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组    
```

代码演示：

```java
package com.jerry.java;

import java.io.File;
import java.io.IOException;

/**
 * @author jerry_jy
 * @create 2022-10-07 20:29
 */
public class FileTest {
    public static void main(String[] args) throws IOException {
        File file = new File("D:" + File.separator + "2.txt");
        System.out.println("**********创建文件*********");
        System.out.println(file.createNewFile());//false
        System.out.println("**********获取绝对路径*********");
        System.out.println(file.getAbsolutePath());//D:\2.txt
        System.out.println("**********获取名称*********");
        System.out.println(file.getName());//2.txt
        System.out.println("**********获取文件长度（即：字节数）。不能获取目录的长度*********");
        System.out.println(file.length());//0
        System.out.println("**********获取最后一次的修改时间，毫秒值*********");
        System.out.println(file.lastModified());//1665148556505
        System.out.println("**********判断是否是文件目录*********");
        System.out.println(file.isDirectory());//false
        System.out.println("**********判断是否是文件*********");
        System.out.println(file.isFile());//true
        System.out.println("**********判断是否存在*********");
        System.out.println(file.exists());//true
        System.out.println("**********判断是否可读*********");
        System.out.println(file.canRead());//true
        System.out.println("**********判断是否可写*********");
        System.out.println(file.canWrite());//true
        System.out.println("**********判断是否隐藏*********");
        System.out.println(file.isHidden());//false
        System.out.println("**********创建文件。若文件存在，则不创建，返回false*********");
        System.out.println(new File("D:" + File.separator + "3.txt").createNewFile());//false
        System.out.println("**********删除文件或者文件夹*********");
        System.out.println(file.delete());//true


        File dir1 = new File("D:/IOTest/dir1");
        if (!dir1.exists()) { // 如果D:/IOTest/dir1不存在，就创建为目录
            dir1.mkdir();
        }
        // 创建以dir1为父目录,名为"dir2"的File对象
        File dir2 = new File(dir1, "dir2");
        if (!dir2.exists()) { // 如果还不存在，就创建为目录
            dir2.mkdirs();
        }
        File dir4 = new File(dir1, "dir3/dir4");
        if (!dir4.exists()) {
            dir4.mkdirs();
        }
        // 创建以dir2为父目录,名为"test.txt"的File对象
        File file1 = new File(dir2, "test.txt");
        if (!file1.exists()) { // 如果还不存在，就创建为文件
            file1.createNewFile();
        }
    }
    
        /*
    public boolean renameTo(File dest):把文件重命名为指定的文件路径
     比如：file1.renameTo(file2)为例：
        要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。
     */
    @Test
    public void test1(){
        File file1 = new File("hello.txt");
        File file2 = new File("D:\\io\\hi.txt");

        boolean renameTo = file2.renameTo(file1);
        System.out.println(renameTo);
    }
    
        File file = new File("D:\\io\\dir1\\dir3\\dir4\\dir5");
        String[] list = file.list();//获取该目录下的String类型的名字
        for (String s : list) {
            System.out.println(s);//2.txt
        }

        File[] files = file.listFiles();//获取该目录下的File数组
        for (File f : files) {
            System.out.println(f);//D:\io\dir1\dir3\dir4\dir5\2.txt
        }
}
```

## IO流原理及流的分类

按操作数据单位不同分为：字节流(8 bit)（InputStream，OutputStream），字符流(16 bit) （Reader，Writer）

- 按数据流的流向不同分为：输入流，输出流 

- 按流的角色的不同分为：节点流，处理流


![image-20221008190732856](E:/typora/image-20221008190732856.png)



```java
 * 二、流的体系结构
 * 抽象基类         节点流（或文件流）                               缓冲流（处理流的一种）
 * InputStream     FileInputStream   (read(byte[] buffer))        BufferedInputStream (read(byte[] buffer))
 * OutputStream    FileOutputStream  (write(byte[] buffer,0,len)  BufferedOutputStream (write(byte[] buffer,0,len) / flush()
 * Reader          FileReader (read(char[] cbuf))                 BufferedReader (read(char[] cbuf) / readLine())
 * Writer          FileWriter (write(char[] cbuf,0,len)           BufferedWriter (write(char[] cbuf,0,len) / flush()
```



![image-20221008190638486](E:/typora/image-20221008190638486.png)



程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件 IO 资源。

FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream  用于读取非文本数据之类的原始字节流。要读取字符流，需要使用 FileReader

### FileRead--读取字符流文件

```java
    @Test
    public void testFileReader() {
        FileReader fileReader = null;
        try {
            //1.实例化File类的对象，指明要操作的文件
            File file = new File("hello.txt");
            //2.提供具体的流
            fileReader = new FileReader(file);
            //3.数据的读入
            //read():返回读入的一个字符。如果达到文件末尾，返回-1
            int data;
            while ((data = fileReader.read()) != -1) {
                System.out.print((char) data);//这里记得一定要强转为char类型，不然读出来就是ASCII
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                //4.流的关闭操作
                if (fileReader != null) {
                    fileReader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    //对read()操作升级：使用read的重载方法
    @Test
    public void testFileReader1() {
        FileReader fileReader = null;
        try {
            //1.File类的实例化
            File file = new File("hello.txt");
            //2.FileReader流的实例化
            fileReader = new FileReader(file);

            //3.读入的操作
            //read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1
            char[] cbuf = new char[5];
            int len;
            while ((len = fileReader.read(cbuf)) != -1) {
//                System.out.print(cbuf);

                //方式一：
                //错误的写法
//                for(int i = 0;i < cbuf.length;i++){
//                    System.out.print(cbuf[i]);
//                }
                //正确的写法
//                for(int i = 0;i < len;i++){
//                    System.out.print(cbuf[i]);
//                }

                //方式二：
                //错误的写法,对应着方式一的错误的写法
//                String str = new String(cbuf);
//                System.out.print(str);
                //正确的写法
                String str = new String(cbuf, 0, len);
                System.out.print(str);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fileReader != null) {
                    fileReader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```

### FileWrite

```java
    /*
    从内存中写出数据到硬盘的文件里。

    说明：
    1. 输出操作，对应的File可以不存在的。并不会报异常
    2.
     File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。
     File对应的硬盘中的文件如果存在：
            如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原有文件的覆盖
            如果流使用的构造器是：FileWriter(file,true):不会对原有文件覆盖，而是在原有文件基础上追加内容

 */
    @Test
    public void testFileWriter() {
        FileWriter fileWriter = null;
        try {
            //1.提供File类的对象，指明写出到的文件
            File file = new File("hello1.txt");
            fileWriter = new FileWriter(file, false);

            //3.写出的操作
            fileWriter.write("I hava a dream!");
            fileWriter.write("人需要有一个梦想！");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                //4.流资源的关闭
                if (fileWriter != null) {
                    fileWriter.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```

### FileReaderFileWriter

```java
    @Test
    public void testFileReaderFileWriter() {
        FileReader fileReader = null;
        FileWriter fileWriter = null;
        try {
            //1.创建File类的对象，指明读入和写出的文件
            File srcFile = new File("hello.txt");
            File destFile = new File("hello2.txt");
            //2.创建输入流和输出流的对象
            fileReader = new FileReader(srcFile);
            fileWriter = new FileWriter(destFile);

            //3.数据的读入和写出操作
            char[] cbuf = new char[5];
            int len;
            while ((len = fileReader.read(cbuf)) != -1) {
                fileWriter.write(cbuf, 0, len);
            }

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fileReader != null) {
                    fileReader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (fileWriter != null) {
                    fileWriter.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```

### FileInputStream--读取字节流文件

定义文件路径时，注意：可以用“/”或者“\\”。 

在写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文 件将被覆盖。 

如果使用构造器FileOutputStream(file,true)，则目录下的同名文件不会被覆盖， 在文件内容末尾追加内容。 

在读取文件时，必须保证该文件已存在，否则报异常。 

字节流操作字节，比如：.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt , .excel

字符流操作字符，只能操作普通文本文件。最常见的文本文 件：.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc,excel,ppt这些不是文本文件。



```java
    /**
     * 测试FileInputStream和FileOutputStream的使用
     * <p>
     * 结论：
     * 1. 对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理
     * 2. 对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,excel...)，使用字节流处理
     */
    //使用字节流FileInputStream处理文本文件，可能出现乱码。
    @Test
    public void testFileInputStream() {
        FileInputStream fis = null;
        try {
            File file = new File("hello.txt");
            fis = new FileInputStream(file);
            byte[] buffer = new byte[5];
            int len;
            while ((len = fis.read(buffer)) != -1) {
                System.out.println(new String(buffer, 0, len));//读取字符流文件已经出现了乱码
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fis != null) {
                    fis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```

### FileInputOutputStream

```java
    /*
    实现对图片的复制操作
     */
    @Test
    public void testFileInputOutputStream() {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            File srcFile = new File("java.jpg");
            File destFile = new File("java1.jpg");
            fis = new FileInputStream(srcFile);
            fos = new FileOutputStream(destFile);
            byte[] buffer = new byte[5];
            int len;
            while ((len = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fos != null) {
                    fos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (fis != null) {
                    fis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```

### 字节流进行指定路径下大文件的复制

```java
    //指定路径下文件的复制
    public void copyFile(String srcPath, String destPath) {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            File srcFile = new File(srcPath);
            File destFile = new File(destPath);
            fis = new FileInputStream(srcFile);
            fos = new FileOutputStream(destFile);

            byte[] buffer = new byte[1024];
            int len;
            while ((len = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fos != null) {
                    fos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (fis != null) {
                    fis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    @Test
    public void testCopyFile(){
        long start = System.currentTimeMillis();

        String srcPath = "E:\\0课程资料\\密码学\\1.mp4";
        String destPath = "E:\\0课程资料\\密码学\\1_1.mp4";

        copyFile(srcPath, destPath);

        long end = System.currentTimeMillis();
        System.out.println("复制操作花费的时间为：" + (end - start));//2619ms
    }
```





### BufferedStream

为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类 时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。

![image-20221008191239864](E:/typora/image-20221008191239864.png)

缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：

- ​	BufferedInputStream 和 BufferedOutputStream 

- ​	BufferedReader 和 BufferedWriter


注意：

当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区 

当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从 文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中 读取下一个8192个字节数组。 

向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满， BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法 flush()可以强制将缓冲区的内容全部写入输出流 

关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也 会相应关闭内层节点流 

flush()方法的使用：手动将buffer中内容写入文件 

如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷 新缓冲区，关闭后不能再写出

![image-20221008191736208](E:/typora/image-20221008191736208.png)



#### 实现非文本文件的复制

```java
    /**
     * 处理流之一：缓冲流的使用
     * <p>
     * 1.缓冲流：
     * BufferedInputStream
     * BufferedOutputStream
     * BufferedReader
     * BufferedWriter
     * <p>
     * 2.作用：提供流的读取、写入的速度
     * 提高读写速度的原因：内部提供了一个缓冲区
     * <p>
     * 3. 处理流，就是“套接”在已有的流的基础上。
     */
    @Test
    public void BufferedStreamTest() {
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        try {
            //1.造文件
            File srcFile = new File("java.jpg");
            File destFile = new File("java2.jpg");
            //2.造流
            //2.1 造节点流
            FileInputStream fis = new FileInputStream(srcFile);
            FileOutputStream fos = new FileOutputStream(destFile);
            //2.2 造缓冲流
            bis = new BufferedInputStream(fis);
            bos = new BufferedOutputStream(fos);
            //3.复制的细节：读取、写入
            byte[] buffer = new byte[10];
            int len;
            while ((len = bis.read(buffer)) != -1) {
                bos.write(buffer, 0, len);
                bos.flush();//刷新缓冲区
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //4.资源关闭
            //要求：先关闭外层的流，再关闭内层的流，带缓冲流的close()方法在关闭流之前会刷新缓冲区
            try {
                if (bos != null) {
                    bos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (bis != null) {
                    bis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.
//        fos.close();
//        fis.close();
    }
```

#### 实现文本文件的复制

```java
    /*
    使用BufferedReader和BufferedWriter实现文本文件的复制

     */
    @Test
    public void testBufferedReaderBufferedWriter() {
        BufferedReader br = null;
        BufferedWriter bw = null;
        try {
            br = new BufferedReader(new FileReader(new File("dbcp.txt")));
            bw = new BufferedWriter(new FileWriter(new File("dbcp_1.txt")));
            //读写操作
            //方式一：使用char[]数组
//            char[] cbuf = new char[10];
//            int len;
//            while ((len=br.read(cbuf))!=-1){
//                bw.write(cbuf, 0, len);
//                bw.flush();
//            }
            //方式二：使用String
            String data;
            while ((data = br.readLine()) != null) {
                //方法一：
//                bw.write(data + "\n");//data中不包含换行符
                //方法二：
                bw.write(data);
                bw.newLine();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                if (bw!=null){
                    bw.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (br!=null){
                    br.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```

#### BufferedStream实现文件复制的方法

```java
    //实现文件复制的方法
    public void copyFileWithBuffered(String srcPath, String destPath) {
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        try {
            //1.造文件
            File srcFile = new File(srcPath);
            File destFile = new File(destPath);
            //2.造流
            //2.1 造节点流
            FileInputStream fis = new FileInputStream(srcFile);
            FileOutputStream fos = new FileOutputStream(destFile);
            //2.2 造缓冲流
            bis = new BufferedInputStream(fis);
            bos = new BufferedOutputStream(fos);
            //3.复制的细节：读取、写入
            byte[] buffer = new byte[1024];
            int len;
            while ((len = bis.read(buffer)) != -1) {
                bos.write(buffer, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //4.资源关闭
            //要求：先关闭外层的流，再关闭内层的流
            try {
                if (bos != null) {
                    bos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (bis != null) {
                    bis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.
//        fos.close();
//        fis.close();
    }

    @Test
    public void testCopyFileWithBuffered() {
        long start = System.currentTimeMillis();
        String srcPath = "E:\\0课程资料\\密码学\\1.mp4";
        String destPath = "E:\\0课程资料\\密码学\\1_1.mp4";
        copyFileWithBuffered(srcPath, destPath);
        long end = System.currentTimeMillis();
        System.out.println("复制操作花费的时间为：" + (end - start));//336
    }
```



#### 获取文本上每个字符出现的次数

```java
    /*
    获取文本上每个字符出现的次数
    提示：遍历文本的每一个字符；字符及出现的次数保存在Map中；将Map中数据写入文件
     */
        /*
    说明：如果使用单元测试，文件相对路径为当前module
    如果使用main()测试，文件相对路径为当前工程
     */
    @Test
    public void testWordCount() {
        FileReader fr = null;
        BufferedWriter bw = null;
        try {
            HashMap<Character, Integer> map = new HashMap<>();
            fr = new FileReader("dbcp.txt");
            int data;
            while ((data = fr.read()) != -1) {
                char c = (char) data;
                if (map.get(c) == null) {
                    map.put(c, 1);
                } else {
                    map.put(c, map.get(c) + 1);
                }
            }

            bw = new BufferedWriter(new FileWriter("WordCount.txt"));
            Set<Map.Entry<Character, Integer>> entrySet = map.entrySet();
            for (Map.Entry<Character, Integer> entry : entrySet) {
                switch (entry.getKey()) {
                    case ' ':
                        bw.write("空格=" + entry.getValue());
                        break;
                    case '\t':
                        bw.write("tab键=" + entry.getValue());
                        break;
                    case '\r':
                        bw.write("回车=" + entry.getValue());
                        break;
                    case '\n':
                        bw.write("换行=" + entry.getValue());
                        break;
                    default:
                        bw.write(entry.getKey() + "=" + entry.getValue());
                        break;
                }
                bw.newLine();
            }


        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bw != null) {
                    bw.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (fr != null) {
                    fr.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
```



### 转换流

转换流提供了在字节流和字符流之间的转

Java API提供了两个转换流： 

InputStreamReader：将InputStream转换为Reader 

OutputStreamWriter：将Writer转换为OutputStream

字节流中的数据都是字符时，转成字符流操作更高效。



#### InputStreamReader

实现将字节的输入流按指定字符集转换为字符的输入流。 

需要和InputStream“套接”。 

构造器 

- ​	public InputStreamReader(InputStream in) 

- ​	public InputSreamReader(InputStream in,String charsetName)


![image-20221008204441020](E:/typora/image-20221008204441020.png)



```java
    //InputStreamReader的使用，实现字节的输入流到字符的输入流的转换
    @Test
    public void test1() {
        InputStreamReader isr = null;
        try {
            FileInputStream fis = new FileInputStream("dbcp.txt");
            isr = new InputStreamReader(fis, "UTF-8");

            char[] cbuf = new char[20];
            int len;
            while ((len = isr.read(cbuf)) != -1) {
                System.out.println(new String(cbuf, 0, len));
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (isr != null) {
                    isr.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```



#### OutputStreamWriter

实现将字符的输出流按指定字符集转换为字节的输出流。 

需要和OutputStream“套接”。 

构造器 

- ​	public OutputStreamWriter(OutputStream out) 

- ​	public OutputSreamWriter(OutputStream out,String charsetName)


```java
    /*
    此时处理异常的话，仍然应该使用try-catch-finally

    综合使用InputStreamReader和OutputStreamWriter
 */
    @Test
    public void test2() throws Exception {
        //1.造文件、造流
        File file1 = new File("dbcp.txt");
        File file2 = new File("dbcp_gbk");

        FileInputStream fis = new FileInputStream(file1);
        FileOutputStream fos = new FileOutputStream(file2);

        InputStreamReader isr = new InputStreamReader(fis, "UTF-8");
        OutputStreamWriter osw = new OutputStreamWriter(fos, "GBK");

        //2.读写过程
        char[] cbuf = new char[20];
        int len;
        while ((len= isr.read(cbuf))!=-1){
            osw.write(cbuf, 0, len);
        }

        //3.关闭资源
        osw.close();
        isr.close();
    }
```

#### 字符集

```java
* 字符集
* ASCII：美国标准信息交换码。
* 	用一个字节的7位可以表示。
* ISO8859-1：拉丁码表。欧洲码表
* 	用一个字节的8位表示。
* GB2312：中国的中文编码表。最多两个字节编码所有字符
* GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码
* Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。
* UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。
```

## 其他类型的流（不重要）

### 标准输入、输出流

System.in的类型是InputStream

System.out的类型是PrintStream，其是OutputStream的子类 FilterOutputStream 的子类

```java
从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，
直至当输入“e”或者“exit”时，退出程序。

方法一：使用Scanner实现，调用next()返回一个字符串
方法二：使用System.in实现。System.in  --->  转换流 ---> BufferedReader的readLine()
```

```java
// 方式一：采用scanner.next()方法
while (true){
    System.out.println("从键盘输入字符串:");
    Scanner scanner = new Scanner(System.in);
    String str = scanner.next();
    if ("e".equalsIgnoreCase(str)||"exit".equalsIgnoreCase(str)){
        System.out.println("程序结束！");
        break;
    }
    System.out.println(str.toUpperCase());
}

// 方式二：采用BufferedReader
BufferedReader br = null;
while (true) {
    try {
        InputStreamReader isr = new InputStreamReader(System.in);
        br = new BufferedReader(isr);
        System.out.println("从键盘输入字符串:");
        String str = br.readLine();
        if ("e".equalsIgnoreCase(str) || "exit".equalsIgnoreCase(str)) {
            System.out.println("程序结束！");
            break;
        }
        System.out.println(str.toUpperCase());
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            if (br != null) {
                br.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
```

### 打印流

实现将基本数据类型的数据格式转化为字符串输出

打印流：PrintStream和PrintWriter 

- ​	提供了一系列重载的print()和println()方法，用于多种数据类型的输出 

- ​	PrintStream和PrintWriter的输出不会抛出IOException异常 

- ​	PrintStream和PrintWriter有自动flush功能 

- ​	PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。 在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 

- ​	System.out返回的是PrintStream的实例


```java
    @Test
    public void test2() {
        PrintStream ps = null;
        try {
            FileOutputStream fos = new FileOutputStream(new File("D:\\io\\1.txt"));
            ps = new PrintStream(fos, true);
            if (ps != null) {
                System.out.println(ps);
            }
            for (int i = 0; i <= 255; i++) {
                System.out.println((char) i);
                if (i % 50 == 0) {
                    System.out.println();
                }
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            if (ps != null) {
                ps.close();
            }
        }

    }
```

### 数据流

为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。 

数据流有两个类：(用于读取和写出基本数据类型、String类的数据） 

- ​	DataInputStream 和 DataOutputStream 

- ​	分别“套接”在 InputStream 和 OutputStream 子类的流上


DataInputStream中的方法

```java
boolean readBoolean() 		byte readByte()
char readChar() 			float readFloat()
double readDouble() 		short readShort()
long readLong() 			int readInt()
String readUTF() 			void readFully(byte[] b)
```

DataOutputStream中的方法 

- ​	将上述的方法的read改为相应的write即可


```java
    @Test
    public void test3() {
        DataOutputStream dos = null;
        try {
            dos = new DataOutputStream(new FileOutputStream(new File("data.txt")));
            dos.writeUTF("杰瑞");
            dos.flush();
            dos.writeInt(123);
            dos.flush();
            dos.writeBoolean(true);
            dos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (dos != null) {
                    dos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
```



    将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。
    
    注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！


```java
    @Test
    public void test4() {
        DataInputStream dis=null;
        try {
             dis = new DataInputStream(new FileInputStream("data.txt"));
            String name = dis.readUTF();
            int age = dis.readInt();
            boolean isMale = dis.readBoolean();

            System.out.println("name: " + name);
            System.out.println("age: " + age);
            System.out.println("Male: " + isMale);
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                if (dis!=null){
                    dis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```



## 对象流

ObjectInputStream和OjbectOutputSteam 

用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可 以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 

序列化：用ObjectOutputStream类保存基本类型数据或对象的机制 

反序列化：用ObjectInputStream类读取基本类型数据或对象的机制 

ObjectOutputStream和ObjectInputStream不能序列化static和transient修 饰的成员变量

### 对象的序列化

对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从 而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传 输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原 来的Java对象 

序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据， 使其在保存和传输时可被还原 

序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可 序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。 否则，会抛出NotSerializableException异常 

- ​	Serializable 
- ​	Externalizable

凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量： 

- ​	private static final long serialVersionUID; 
- ​	serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象 进行版本控制，有关各版本反序列化时是否兼容。 
- ​	如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自 动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议， 显式声明。 

简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验 证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的 serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同 就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异 常。(InvalidCastException)

### 使用对象流序列化对象

若某个类实现了 Serializable 接口，该类的对象就是可序列化的： 

- 创建一个 ObjectOutputStream 
- 调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象 
- 注意写出一次，操作flush()一次

```java
    /*
序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去
使用ObjectOutputStream实现
 */
    @Test
    public void testObjectOutputStream() {
        ObjectOutputStream oos = null;
        try {
            oos = new ObjectOutputStream(new FileOutputStream(new File("object.dat")));
            oos.writeObject(new String("好好学习"));
            oos.flush();

            oos.writeObject(new Person("Jerry", 22));
            oos.flush();
            oos.writeObject(new Person("Tom", 23, 1001, new Account(8000.0)));
            oos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (oos != null) {
                    oos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

```

反序列化

- 创建一个 ObjectInputStream 
- 调用 readObject() 方法读取流中的对象

强调：如果某个类的属性不是基本数据类型或 String 类型，而是另一个 引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的 Field 的类也不能序列化

```java
    /*
    反序列化：将磁盘文件中的对象还原为内存中的一个java对象
    使用ObjectInputStream来实现
    */
    @Test
    public void testObjectInputStream() {
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream("object.dat"));
            Object obj = ois.readObject();
            String str = (String) obj;

            Person p1 = (Person) ois.readObject();
            Person p2 = (Person) ois.readObject();

            System.out.println(str);
            System.out.println(p1);
            System.out.println(p2);

        } catch (ClassNotFoundException | IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (ois != null) {
                    ois.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```

```java
package com.jerry.java;

import java.io.Serializable;

/**
 * Person需要满足如下的要求，方可序列化
 * 1.需要实现接口：Serializable
 * 2.当前类提供一个全局常量：serialVersionUID
 * 3.除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性
 *   也必须是可序列化的。（默认情况下，基本数据类型可序列化）
 *
 * 补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量
 */

/**
 * @author jerry_jy
 * @create 2022-10-09 11:11
 */
public class Person implements Serializable{
    public static final long serialVersionUID = 123456792251552L;

    private String name;
    private int age;
    private int id;
    private Account acct;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Person(String name, int age, int id) {
        this.name = name;
        this.age = age;
        this.id = id;
    }

    public Person(String name, int age, int id, Account acct) {
        this.name = name;
        this.age = age;
        this.id = id;
        this.acct = acct;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", id=" + id +
                ", acct=" + acct +
                '}';
    }
}
class Account implements Serializable {
    public static final long serialVersionUID =5467945325646L;
    private double balance;

    public Account(double balance) {
        this.balance = balance;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    @Override
    public String toString() {
        return "Account{" +
                "balance=" + balance +
                '}';
    }
}
```

谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化， 是空方法接口，还有其它认识吗？

- 实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后 完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机 制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创 建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里 准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必 关心字节的顺序或者其他任何细节。 
- 由于大部分作为参数的类如String、Integer等都实现了 java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活。



## RandomAccessFile 类

RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并 且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也 可以写。 

RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意 地方来读、写文件 

- 支持只访问文件的部分内容 
- 可以向已存在的文件后追加内容 

RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。 

RandomAccessFile 类对象可以自由移动记录指针： 

- long getFilePointer()：获取文件记录指针的当前位置 
- void seek(long pos)：将文件记录指针定位到 pos 位置

构造器 

- public RandomAccessFile(File file, String mode)  
- public RandomAccessFile(String name, String mode)

创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指 定 RandomAccessFile 的访问模式： 

- r: 以只读方式打开 
- rw：打开以便读取和写入 
- rwd:打开以便读取和写入；同步文件内容的更新 
- rws:打开以便读取和写入；同步文件内容和元数据的更新 

如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件， 如果读取的文件不存在则会出现异常。 如果模式为rw读写。如果文件不 存在则会去创建文件，如果存在则不会创建。

RandomAccessFile读取文件内容

```java
RandomAccessFile raf = new RandomAccessFile(“test.txt”, “rw”）;
raf.seek(5);
byte [] b = new byte[1024];
int off = 0;
int len = 5;
raf.read(b, off, len);
String str = new String(b, 0, len);
System.out.println(str);
raf.close();
```

RandomAccessFile写入文件内容

```java
RandomAccessFile raf = new RandomAccessFile("test.txt", "rw");
raf.seek(5);
//先读出来
String temp = raf.readLine();
raf.seek(5);
raf.write("xyz".getBytes());
raf.write(temp.getBytes());
raf.close();
```

使用RandomAccessFile实现数据的插入效果

```java
    /*
    使用RandomAccessFile实现数据的插入效果
     */
    @Test
    public void test3() throws IOException {
        RandomAccessFile raf = new RandomAccessFile("hello.txt", "rw");
        raf.seek(3);
        StringBuilder builder = new StringBuilder((int) new File("hello.txt").length());
        byte[] buffer = new byte[20];
        int len;
        while ((len=raf.read(buffer))!=-1){
            builder.append(new String(buffer,0,len));
        }
        raf.seek(3);
        raf.write("xyz".getBytes());
        raf.write(builder.toString().getBytes());
        raf.close();
    }
```

## NIO.2中Path、 Paths、Files类的使用

 Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新 的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目 的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于 通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。 

Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网 络编程NIO。

早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所 提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异 常信息。 

NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描 述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资 源也可以不存在。 

在以前IO操作都是这样写的: 

- import java.io.File; 
- File file = new File("index.html"); 

但在Java7 中，我们可以这样写： 

- import java.nio.file.Path;  
- import java.nio.file.Paths;  
- Path path = Paths.get("index.html")

```java
Path Path接口：
String toString() ： 返回调用 Path 对象的字符串表示形式
boolean startsWith(String path) : 判断是否以 path 路径开始
boolean endsWith(String path) : 判断是否以 path 路径结束
boolean isAbsolute() : 判断是否是绝对路径
Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径
Path getRoot() ：返回调用 Path 对象的根路径
Path getFileName() : 返回与调用 Path 对象关联的文件名
int getNameCount() : 返回Path 根目录后面元素的数量
Path getName(int idx) : 返回指定索引位置 idx 的路径名称
Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象
Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象
File toFile(): 将Path转化为File类的对象
```

代码演示：

```java
package com.jerry.java;
/**
 * 1. jdk 7.0 时，引入了 Path、Paths、Files三个类。
 * 2.此三个类声明在：java.nio.file包下。
 * 3.Path可以看做是java.io.File类的升级版本。也可以表示文件或文件目录，与平台无关
 * <p>
 * 4.如何实例化Path:使用Paths.
 * static Path get(String first, String … more) : 用于将多个字符串串连成路径
 * static Path get(URI uri): 返回指定uri对应的Path路径
 */

import org.junit.Test;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * @author jerry_jy
 * @create 2022-10-11 11:17
 */
public class PathTest {

    //如何使用Paths实例化Path
    @Test
    public void test1() {
        Path path1 = Paths.get("D:\\nio\\hello.txt");//new File(String filepath)

        Path path2 = Paths.get("d:\\", "nio\\hello.txt");//new File(String parent,String filename);

        System.out.println(path1);//d:\nio\hello.txt
        System.out.println(path2);//d:\nio\hello.txt

        Path path3 = Paths.get("d:\\", "nio");
        System.out.println(path3);//d:\nio
    }


    //Path中的常用方法
    @Test
    public void test2() {
        Path path1 = Paths.get("d:\\", "nio\\nio1\\nio2\\hello.txt");
        Path path2 = Paths.get("hello.txt");

//		String toString() ： 返回调用 Path 对象的字符串表示形式
        System.out.println(path1);//d:\nio\nio1\nio2\hello.txt

//		boolean startsWith(String path) : 判断是否以 path 路径开始
        System.out.println(path1.startsWith("d:\\nio"));//true
//		boolean endsWith(String path) : 判断是否以 path 路径结束
        System.out.println(path1.endsWith("hello.txt"));//true
//		boolean isAbsolute() : 判断是否是绝对路径
        System.out.println(path1.isAbsolute() + "~");//true~
        System.out.println(path2.isAbsolute() + "~");//false~
//		Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径
        System.out.println(path1.getParent());//d:\nio\nio1\nio2
        System.out.println(path2.getParent());//null
//		Path getRoot() ：返回调用 Path 对象的根路径
        System.out.println(path1.getRoot());//d:\
        System.out.println(path2.getRoot());//null
//		Path getFileName() : 返回与调用 Path 对象关联的文件名
        System.out.println(path1.getFileName() + "~");//hello.txt~
        System.out.println(path2.getFileName() + "~");//hello.txt~
//		int getNameCount() : 返回Path 根目录后面元素的数量
//		Path getName(int idx) : 返回指定索引位置 idx 的路径名称
        for (int i = 0; i < path1.getNameCount(); i++) {
            System.out.println(path1.getName(i) + "*****");
        }

//		Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象
        System.out.println(path1.toAbsolutePath());//d:\nio\nio1\nio2\hello.txt
        System.out.println(path2.toAbsolutePath());//E:\CodeLife\IdeaProject\JVM\chapter13\hello.txt
//		Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象
        Path path3 = Paths.get("d:\\", "nio");
        Path path4 = Paths.get("nioo\\hi.txt");
        path3 = path3.resolve(path4);
        System.out.println(path3);//d:\nio\nioo\hi.txt

//		File toFile(): 将Path转化为File类的对象
        File file = path1.toFile();//Path--->File的转换
//
        Path newPath = file.toPath();//File--->Path的转换

    }

}
```



```java
Files常用方法：
Path copy(Path src, Path dest, CopyOption … how) : 文件的复制
Path createDirectory(Path path, FileAttribute<?> … attr) : 创建一个目录
Path createFile(Path path, FileAttribute<?> … arr) : 创建一个文件
void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错
void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除
Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置
long size(Path path) : 返回 path 指定文件的大小
Files常用方法：用于判断
boolean exists(Path path, LinkOption … opts) : 判断文件是否存在
boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录
boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件
boolean isHidden(Path path) : 判断是否是隐藏文件
boolean isReadable(Path path) : 判断文件是否可读
boolean isWritable(Path path) : 判断文件是否可写
boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在
Files常用方法：用于操作内容
SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连
接，how 指定打开方式。
DirectoryStream<Path> newDirectoryStream(Path path) : 打开 path 指定的目录
InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象
OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象
```

代码演示

```java
    @Test
    public void test1() throws IOException {
        Path path1 = Paths.get("D:\\nio", "hello.txt");
        Path path2 = Paths.get("myHello.txt");

//		Path copy(Path src, Path dest, CopyOption … how) : 文件的复制
        //要想复制成功，要求path1对应的物理上的文件存在。path1对应的文件没有要求。
//		Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING);

//		Path createDirectory(Path path, FileAttribute<?> … attr) : 创建一个目录
        //要想执行成功，要求path对应的物理上的文件目录不存在。一旦存在，抛出异常。
        Path path3 = Paths.get("d:\\nio\\nio1");
//		Files.createDirectory(path3);

        //		Path createFile(Path path, FileAttribute<?> … arr) : 创建一个文件
        //要想执行成功，要求path对应的物理上的文件不存在。一旦存在，抛出异常。
        Path path4 = Paths.get("D:\\nio\\hi.txt");
//        Files.createFile(path4);

//		void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错
//		Files.delete(path4);

//		void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束
        Files.deleteIfExists(path3);

//		Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置
        //要想执行成功，src对应的物理上的文件需要存在，dest对应的文件没有要求。
//		Files.move(path1, path2, StandardCopyOption.ATOMIC_MOVE);

//		long size(Path path) : 返回 path 指定文件的大小
        long size = Files.size(path2);
        System.out.println(size);
    }

    @Test
    public void test2() throws IOException{
        Path path1 = Paths.get("d:\\nio", "hello.txt");
        Path path2 = Paths.get("myHello.txt");

//		boolean exists(Path path, LinkOption … opts) : 判断文件是否存在

        System.out.println(Files.exists(path1, LinkOption.NOFOLLOW_LINKS));

//		boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录
        //不要求此path对应的物理文件存在。
        System.out.println(Files.isDirectory(path1, LinkOption.NOFOLLOW_LINKS));

//		boolean isHidden(Path path) : 判断是否是隐藏文件
        //要求此path对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常。
		System.out.println(Files.isHidden(path1));

//		boolean isReadable(Path path) : 判断文件是否可读
        System.out.println(Files.isReadable(path1));
//		boolean isWritable(Path path) : 判断文件是否可写
        System.out.println(Files.isWritable(path1));
//		boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在
        System.out.println(Files.notExists(path1, LinkOption.NOFOLLOW_LINKS));
    }

    /**
     * StandardOpenOption.READ:表示对应的Channel是可读的。
     * StandardOpenOption.WRITE：表示对应的Channel是可写的。
     * StandardOpenOption.CREATE：如果要写出的文件不存在，则创建。如果存在，忽略
     * StandardOpenOption.CREATE_NEW：如果要写出的文件不存在，则创建。如果存在，抛异常
     * @throws IOException
     */
    @Test
    public void test3() throws IOException{
        Path path = Paths.get("D:\\nio\\hello.txt");

        InputStream inputStream = Files.newInputStream(path, StandardOpenOption.READ);
        OutputStream outputStream = Files.newOutputStream(path, StandardOpenOption.WRITE, StandardOpenOption.CREATE);

        SeekableByteChannel byteChannel = Files.newByteChannel(path, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);

        Path path1 = Paths.get("D:\\IOTest");
        DirectoryStream<Path> paths = Files.newDirectoryStream(path1);
        Iterator<Path> iterator = paths.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }

    }
```



# 装饰设计模式

回想一下 Java 当中的各种输入输出流，各种功能一层嵌套一层，就好像不断得 给一个产品加功能，加完以后在消费者看来，原来是是什么产品现在还是什么产 品，只不过用的时候功能增加了。

## 1.装饰模式的概念:

装饰模式是动态的给一个对象添加一些额外的功能，就增加功能来说，装饰 模式比生成子类更为灵活。 

装饰模式是在不必改变原类文件和使用继承的情况下，动态的扩展一个对象 的功能。提供比继承更多的灵活性。 装饰模式是创建一个包装对象，也就是使用装饰来包裹真实的对象。



## 2.装饰模式的实现方式

- 装饰对象和真实对象有相同的接口/抽象类。这样客户端对象就能以和真实对 象相同的方式和装饰对象交互。 
- 装饰对象包含一个真实对象的引用（reference）。 
- 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。 
- 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了 在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象 的设计中，通常是通过继承来实现对给定类的功能扩展。

## 3.代码演示

```java
package com.jerry.java;
/*
 * 变形金刚在变形前是一辆汽车，它可以在陆地上移动。当它变成机器人之后除了能够在陆地上移动之外，还可以说话；
 * 如果需要，它还可以变成飞机，除了在陆地上移动还可以在天空中飞翔。
 */

/**
 * @author jerry_jy
 * @create 2022-10-11 16:03
 */
public class DecoratorDemo {
    public static void main(String[] args) {
        Transform machine = new Car();
        machine.move();

        Robot robot = new Robot(machine);
        robot.move();

        AirPlain airPlain1 = new AirPlain(machine);
        airPlain1.move();
        AirPlain airPlain2 = new AirPlain(robot);
        airPlain2.move();


    }
}

/**
 * @Description 声明一个move方法，无论变形金刚如何改变该方法始终都有，是具体构件和抽象装饰类共有的方法。
 */
interface Transform {
    public void move();
}

/**
 * ConcreteComponent（具体构件）：Car.java 提供了move方法的实现，运用构造函数初始化输出当前状态，它是一个可以被装饰的类。在这里Car
 * 被声明为final类型，说明不能通过继承来拓展其功能，需运用类之间的关联关系来拓展。即装饰器装饰
 */
final class Car implements Transform {
    // 初始化
    public Car() {
        System.out.println("变形金刚->车");
    }

    @Override
    public void move() {
        System.out.println("在陆地上移动");
    }
}

/**
 * Decorator（抽象装饰类）：Changer.java 定义一个抽象构件类型的transform，通过构造函数或者setter方法来给该对象赋值，同时也通过调用transform对象
 * 来实现move方法，这样可以保证原方法不被丢失，而且可以在它的子类中增加新的方法，拓展原有功能。
 */
class Change implements Transform {

    private Transform transform;

    public Change(Transform transform) {
        this.transform = transform;
    }

    @Override
    public void move() {
        transform.move();
    }
}

/**
 * @Description ConcreteDecorator（具体装饰类）：这里采用的是半透明
 */
class Robot extends Change {

    public Robot(Transform transform) {
        super(transform);
        System.out.println("->机器人");
    }

    @Override
    public void move() {
        super.move();
        say();
    }

    private void say() {
        System.out.println("说话");
    }

}

class AirPlain extends Change {

    public AirPlain(Transform transform) {
        super(transform);
        System.out.println("->飞机");

    }

    @Override
    public void move() {
        super.move();
        fly();
    }

    private void fly() {
        System.out.println("飞翔");
    }

}
```

## 4.装饰器模式的应用场景 

1、需要扩展一个类的功能。 

2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点， 继承的功能是静态的，不能动态增删。）

## 5.缺点 

- 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。 
- 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。 
- 装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具 体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可 以改变 Component 接口，增加新的公开的行为，实现“半透明”的装饰者模式。 在实际项目中要做出最佳选择。





# 网络编程

## 网络通信协议

### InetAdress类

InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取 InetAddress实例

```java
public String getHostAddress()：返回 IP 地址字符串（以文本表现形式）。
public String getHostName()：获取此 IP 地址的主机名
public boolean isReachable(int timeout)：测试是否可以达到该地址
```



### 网络通信协议--TCP



![image-20221012194434190](E:/typora/image-20221012194434190.png)



![image-20221012194457386](E:/typora/image-20221012194457386.png)



### Socket

Socket分类： 

- 流套接字（stream socket）：使用TCP提供可依赖的字节流服务 
- 数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务

Socket类的常用构造器： 

- public Socket(InetAddress address,int port)创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 
- public Socket(String host,int port)创建一个流套接字并将其连接到指定主机上的指定端口号。 

#### Socket类的常用方法：

```java
public InputStream getInputStream()返回此套接字的输入流。可以用于接收网络消息
public OutputStream getOutputStream()返回此套接字的输出流。可以用于发送网络消息
public InetAddress getInetAddress()此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回null
public InetAddress getLocalAddress()获取套接字绑定的本地地址。 即本端的IP地址
public int getPort()此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。
public int getLocalPort()返回此套接字绑定到的本地端口。 如果尚未绑定套接字，则返回 -1。即本端的端口号。
public void close()关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接
或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和OutputStream。
public void shutdownInput()如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。
public void shutdownOutput()禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。
```



#### 基于TCP的Socket通信

![image-20221012195251552](E:/typora/image-20221012195251552.png)



#### 基于Socket的TCP编程

 客户端Socket的工作过程包含以下四个基本的步骤： 

- 创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端 响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。 
- 打开连接到 Socket 的输入/出流： 使用 getInputStream()方法获得输入流，使用 getOutputStream()方法获得输出流，进行数据传输 
- 按照一定的协议对 Socket 进行读/写操作：通过输入流读取服务器放入线路的信息 （但不能读取自己放入线路的信息），通过输出流将信息写入线程。 
- 关闭 Socket：断开客户端到服务器的连接，释放线路

客户端程序可以使用Socket类创建对象，创建的同时会自动向服务器方发起连接。Socket的构造器是：

```java
Socket(String host,int port)throws UnknownHostException,IOException：向服务器(域名是
host。端口号为port)发起TCP连接，若成功，则创建Socket对象，否则抛出异常。
Socket(InetAddress address,int port)throws IOException：根据InetAddress对象所表示的
IP地址以及端口号port发起连接。
```

代码演示：

```java
    //客户端
    @Test
    public void client() {
        Socket socket = null;
        OutputStream os = null;
        try {
            //1.创建Socket对象，指明服务器端的ip和端口号
            InetAddress inet = InetAddress.getByName("192.168.56.100");
            socket = new Socket(inet, 8899);
            //2.获取一个输出流，用于输出数据
            os = socket.getOutputStream();
            //3.写出数据的操作
            os.write("你好，我是客户端".getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //4.资源的关闭
            try {
                if (os != null) {
                    os.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (socket != null) {
                    socket.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```



服务器程序的工作过程包含以下四个基本的步骤：

- 调用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口 上。用于监听客户端的请求。 
- 调用 accept()：监听连接请求，如果客户端请求连接，则接受连接，返回通信 套接字对象。 
- 调用 该Socket类对象的 getOutputStream() 和 getInputStream ()：获取输出 流和输入流，开始网络数据的发送和接收。 
- 关闭ServerSocket和Socket对象：客户端访问结束，关闭通信套接字。

ServerSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口 中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字 连接的ServerSocket对象。

代码演示：

```java
    //服务端
    @Test
    public void server() {
        ServerSocket ss = null;
        Socket socket = null;
        InputStream is = null;
        ByteArrayOutputStream baos = null;
        try {
            //1.创建服务器端的ServerSocket，指明自己的端口号
            ss = new ServerSocket(8899);
            //2.调用accept()表示接收来自于客户端的socket
            socket = ss.accept();
            //3.获取输入流
            is = socket.getInputStream();

            //不建议这样写，可能会有乱码
//        byte[] buffer = new byte[1024];
//        int len;
//        while((len = is.read(buffer)) != -1){
//            String str = new String(buffer,0,len);
//            System.out.print(str);
//        }

            //4.读取输入流中的数据
            baos = new ByteArrayOutputStream();
            byte[] buffer = new byte[5];
            int len;
            while ((len = is.read(buffer)) != -1) {
                baos.write(buffer, 0, len);
            }
            System.out.println(baos.toString());

            System.out.println("收到了来自：" + socket.getInetAddress().getHostAddress() + "的数据");

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //5.关闭资源
            try {
                if (baos != null) {
                    baos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (is != null) {
                    is.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (socket != null) {
                    socket.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (ss != null) {
                    ss.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```



### UDP网络通信

类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。 

UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证 UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。 

DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP 地址和端口号以及接收端的IP地址和端口号。 

UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和 接收方的连接。如同发快递包裹一样。



#### DatagramSocket 类的常用方法

```java
public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被
绑定到通配符地址，IP 地址由内核来选择。
public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。
public void close()关闭此数据报套接字。
public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将
要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。
public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时，DatagramPacket
的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。
public InetAddress getLocalAddress()获取套接字绑定的本地地址。
public int getLocalPort()返回此套接字绑定的本地主机上的端口号。java
public InetAddress getInetAddress()返回此套接字连接的地址。如果套接字未连接，则返回 null。
public int getPort()返回此套接字的端口。如果套接字未连接，则返回 -1。
```

#### DatagramPacket类的常用方法

```java
public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 length 参数必须小于等于 buf.length。
public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length参数必须小于等于 buf.length。
public InetAddress getAddress()返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收的。
public int getPort()返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。
public byte[] getData()返回数据缓冲区。接收到的或将要发送的数据从缓冲区java中的偏移量 offset 处始，持续 length 长度。
public int getLength()返回将要发送或接收到的数据的长度。
```

#### 代码演示：

```java
    //发送端
    @Test
    public void sender() throws IOException {
        DatagramSocket socket = new DatagramSocket();

        String str = "我是UDP";
        byte[] data = str.getBytes(StandardCharsets.UTF_8);
        InetAddress localHost = InetAddress.getLocalHost();
        DatagramPacket packet = new DatagramPacket(data, 0, data.length, localHost, 8888);

        socket.send(packet);
        socket.close();
    }

    //接收端
    @Test
    public void receiver() throws IOException {
        DatagramSocket socket = new DatagramSocket(8888);

        byte[] buffer = new byte[1024];java
        DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);

        socket.receive(packet);
        System.out.println(new String(packet.getData(), 0, packet.getLength()));
        socket.close();

    }
```



### URL网络编程

URL类常用方法

```java
public String getProtocol( ) 获取该URL的协议名
public String getHost( ) 获取该URL的主机名
public String getPort( ) 获取该URL的端口号
public javaString getPath( ) 获取该URL的文件路径
public String getFile( ) 获取该URL的文件名
public String getQuery( ) 获取该URL的查询名
```



URLConnection类

```java
package com.jerry;

import javax.net.ssl.HttpsURLConnection;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;

/**
 * @author jerry_jy
 * @create 2022-10-13 17:01
 */
public class URLTest1 {
    public static void main(String[] args) {
        URL url = null;
        InputStream is =null;
        FileOutputStream fos =null;
        HttpsURLConnection urlConnection =null;
        try {
            url = new URL("http://localhost:8080/examples/beauty.jpg");
             urlConnection = (HttpsURLConnection) url.openConnection();
            urlConnection.connect();

             is = urlConnection.getInputStream();
             fos = new FileOutputStream("day10\\beauty3.jpg");

            byte[] buffer = new byte[1024];
            int len;
            while ((len=is.read(buffer))!=-1){
                fos.write(buffer, 0, len);
            }
            System.out.println("下载完成");
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                if (is!=null){
                    is.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (fos!=null){
                    fos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (urlConnection!=null){
                urlConnection.disconnect();java
            }
        }

    }
}
```

URI、URL和URN的区别

<font color="red" size="4">URI，是uniform resource identifier，统一资源标识符</font>，用来唯一的标识一个 资源。而<font color="red" size="4">URL是uniform resource locator，统一资源定位符</font>，它是一种具体 的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 而URN，uniform resource name，统一资源命名，是通过名字来标识资源， 比如mailto:java-net@java.sun.com。也就是说，URI是以一种抽象的，高层 次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL 和URN都是一种URI。

![image-20221013165512786](E:/typora/image-20221013165512786.png)

小 结：

- 位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。 
- 客户端－服务器是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定 服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。端口号 是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。套接字用于连接客户 端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实 现面向连接的会话。 
- Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP  地址，该对象里有两个字段：主机名(String) 和 IP 地址(int)。 
- 类 Socket 和 ServerSocket 实现了基于TCP协议的客户端－服务器程序。Socket是客户端 和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输 通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络 拥挤等问题，它保证数据可靠的传送。 
- 类 URL 和 URLConnection 提供了最高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之 间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去





# Java反射机制



Reflection

加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一 个 类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可 以通过这个对象看到类的结构





![image-20221013192347358](E:/typora/image-20221013192347358.png)



## 获取Class类的实例(四种方法)

```java
    //获取Class的实例的方式（前三种方式需要掌握）
    @Test
    public void test3() throws ClassNotFoundException {
        //方式一：调用运行时类的属性：.class
        Class<Person> clazz1 = Person.class;
        System.out.println(clazz1);//class com.jerry.java.Person

        //方式二：通过运行时类的对象,调用getClass()
        Person person = new Person();
        Class clazz2 = person.getClass();
        System.out.println(clazz2);//Person()   class com.jerry.java.Person

        //方式三：调用Class的静态方法：forName(String classPath)
        Class<?> clazz3 = Class.forName("com.jerry.java.Person");
        System.out.println(clazz3);//class com.jerry.java.Person

        System.out.println(clazz1 == clazz2);//true
        System.out.println(clazz1 == clazz3);//true

        //方式四：使用类的加载器：ClassLoader  (了解)
        ClassLoader classLoader = ReflectionTest.class.getClassLoader();
        Class<?> clazz4 = classLoader.loadClass("com.jerry.java.Person");
        System.out.println(clazz4);//class com.jerry.java.Person

        System.out.println(clazz1 == clazz4);//true
    }
```

哪些类型可以有Class对象？

（1）class： 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 

（2）interface：接口 

（3）[]：数组 

（4）enum：枚举 

（5）annotation：注解@interface 

（6）primitive type：基本数据类型 

（7）void

```java
    //Class实例可以是哪些结构的说明：
    @Test
    public void test4(){
        Class c1 = Object.class;
        Class c2 = Comparable.class;
        Class c3 = String[].class;
        Class c4 = int[][].class;
        Class c5 = ElementType.class;
        Class c6 = Override.class;
        Class c7 = int.class;
        Class c8 = void.class;
        Class c9 = Class.class;

        int[] a = new int[10];
        int[] b = new int[100];
        Class c10 = a.getClass();
        Class c11 = b.getClass();
        // 只要数组的元素类型与维度一样，就是同一个Class
        System.out.println(c10 == c11);//true
```



## 类的加载与ClassLoader的理解

![image-20221013221957148](E:/typora/image-20221013221957148.png)



四种类加载器代码演示：

```java
    @Test
    public void test1() {
        //对于自定义类，使用系统类加载器进行加载
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2
       
        //调用系统类加载器的getParent()：获取扩展类加载器
        ClassLoader classLoader1 = classLoader.getParent();
        System.out.println(classLoader1);//sun.misc.Launcher$ExtClassLoader@28a418fc

        //调用扩展类加载器的getParent()：无法获取引导类加载器
        //引导类加载器主要负责加载java的核心类库，无法加载自定义类的。
        ClassLoader classLoader2 = classLoader1.getParent();
        System.out.println(classLoader2);//null

        ClassLoader classLoader3 = String.class.getClassLoader();
        System.out.println(classLoader3);//null
    }
```



通过ClassLoader用来读取Properties配置文件

```java
    @Test
    public void test2() throws Exception {
        Properties pros = new Properties();
        //此时的文件默认在当前的module下。
        //读取配置文件的方式一：
//        FileInputStream fis = new FileInputStream("jdbc.properties");
//        pros.load(fis);

        //读取配置文件的方式二：使用ClassLoader
        //配置文件默认识别为：当前module的src下
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        InputStream is = classLoader.getResourceAsStream("jdbc.properties");
        pros.load(is);

        String name = pros.getProperty("name");
        String password = pros.getProperty("password");
        System.out.println("name = " + name + ",password = " + password);
    }
```



## 通过反射创建对应的运行时类的对象

```java
package com.jerry.java1;

import org.junit.Test;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * @author jerry_jy
 * @create 2022-10-14 10:04
 */
public class ReflectionTest {

    /*
    调用运行时类中指定的结构：属性、方法、构造器
     */

    @Test
    public void testField() throws Exception {
        Class<Person> clazz = Person.class;
        //创建运行时类的对象
        Person person = clazz.newInstance();

        //获取指定的属性：要求运行时类中属性声明为public
        //通常不采用此方法
        Field id = clazz.getField("id");


        /*
        设置当前属性的值

        set():参数1：指明设置哪个对象的属性   参数2：将此属性值设置为多少
         */
        id.set(person, 1001);

        Object pID = id.get(person);
        System.out.println(pID);

    }

    /*
    如何操作运行时类中的指定的属性 -- 需要掌握
     */
    @Test
    public void testField1() throws Exception {
        Class<Person> clazz = Person.class;

        //创建运行时类的对象
        Person person = clazz.newInstance();

        //1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性
        Field name = clazz.getDeclaredField("name");
        //2.保证当前属性是可访问的
        name.setAccessible(true);
        //3.获取、设置指定对象的此属性值
        name.set(person,"Tom");

        System.out.println(name.get(person));
    }

    /*
    如何操作运行时类中的指定的方法 -- 需要掌握
     */
    @Test
    public void testMethod() throws Exception {
        Class<Person> clazz = Person.class;
        //创建运行时类的对象
        Person person = clazz.newInstance();
        /*
        1.获取指定的某个方法
        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表
         */
        Method show = clazz.getDeclaredMethod("show", String.class);
        //2.保证当前方法是可访问的
        show.setAccessible(true);
        /*
        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参
        invoke()的返回值即为对应类中调用的方法的返回值。
         */
        Object obj = show.invoke(person, "CHN");
        System.out.println(obj);


        System.out.println("*************如何调用静态方法*****************");

        // private static void showDesc()
        Method showDesc = clazz.getDeclaredMethod("showDesc");
        showDesc.setAccessible(true);
        //如果调用的运行时类中的方法没有返回值，则此invoke()返回null
//        Object o = showDesc.invoke(Person.class);
        Object o = showDesc.invoke(person);
        System.out.println(o);//我是一个可爱的人    null==>返回值是null，因为方法是void

    }


    /*
    如何调用运行时类中的指定的构造器
     */
    @Test
    public void testConstructor() throws Exception {
        Class<Person> clazz = Person.class;

        //private Person(String name)
        /*
        1.获取指定的构造器
        getDeclaredConstructor():参数：指明构造器的参数列表
         */

        Constructor<Person> constructor = clazz.getDeclaredConstructor(String.class);

        //2.保证此构造器是可访问的
        constructor.setAccessible(true);

        //3.调用此构造器创建运行时类的对象
        Person person = constructor.newInstance("Tom");
        System.out.println(person);
    }
}

```

## 代理模式：动态代理与AOP（Aspect Orient Programming)

代理设计模式的原理

使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原 始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上

静态代理

```java
package com.jerry.java;

/**
 * @author jerry_jy
 * @create 2022-10-14 10:32
 */
public class StaticProxyTest {

    public static void main(String[] args) {
        //创建被代理类的对象
        NikeClothFactory nike = new NikeClothFactory();
        //创建代理类的对象
        ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nike);
        proxyClothFactory.produceCloth();
    }
}
interface ClothFactory{
    void produceCloth();
}

//代理类
class ProxyClothFactory implements ClothFactory{

    private ClothFactory factory;//用被代理类对象进行实例化

    public ProxyClothFactory(ClothFactory factory) {
        this.factory = factory;
    }

    @Override
    public void produceCloth() {
        System.out.println("代理工厂做一些准备工作");

        factory.produceCloth();

        System.out.println("代理工厂做一些后续的收尾工作");

    }
}

//被代理类
class NikeClothFactory implements ClothFactory{

    @Override
    public void produceCloth() {
        System.out.println("Nike工厂生产一批运动服");
    }
}

```



动态代理

```java
package com.jerry.java;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @author jerry_jy
 * @create 2022-10-14 10:37
 */

public class ProxyTest {
    /*
    动态代理的举例
     */
    public static void main(String[] args) {
        SuperMan superMan = new SuperMan();
        //proxyInstance:代理类的对象
        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);
        //当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法
        String belief = proxyInstance.getBelief();
        System.out.println(belief);

        proxyInstance.eat("四川麻辣烫");

        System.out.println("*****************************");

        NikeClothFactory nikeClothFactory = new NikeClothFactory();
        ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);
        proxyClothFactory.produceCloth();
    }
}
interface Human{

    String getBelief();

    void eat(String food);

}
//被代理类
class SuperMan implements Human{

    @Override
    public String getBelief() {
        return "I believe I can fly!";
    }

    @Override
    public void eat(String food) {
        System.out.println("我喜欢吃" + food);
    }
}

class HumanUtil{

    public void method1(){
        System.out.println("====================通用方法一====================");

    }

    public void method2(){
        System.out.println("====================通用方法二====================");
    }

}

/*
要想实现动态代理，需要解决的问题？
问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。
问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。
 */
class ProxyFactory{
    //调用此方法，返回一个代理类的对象。解决问题一
    public static Object getProxyInstance(Object obj) {//obj:被代理类的对象
        MyInvocationHandler handler = new MyInvocationHandler();
        handler.bind(obj);
        return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);
    }
}

class MyInvocationHandler implements InvocationHandler{

    private Object obj;//需要使用被代理类的对象进行赋值

    public void bind(Object obj){
        this.obj = obj;
    }

    //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()
    //将被代理类要执行的方法a的功能就声明在invoke()中
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        HumanUtil util = new HumanUtil();
        util.method1();
        //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法
        //obj:被代理类的对象
        Object returnValue = method.invoke(obj, args);

        util.method2();
        //上述方法的返回值就作为当前类中的invoke()的返回值。
        return returnValue;
    }
}
```



# Java8新特性



## Lambda表达式

Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。



语法：

![image-20221014165431749](E:/typora/image-20221014165431749.png)

![image-20221014165546999](E:/typora/image-20221014165546999.png)





## 函数式(Functional)接口

什么是函数式(Functional)接口

- 只包含一个抽象方法的接口，称为函数式接口。
- 你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式 抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）
- 我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。 
- 在java.util.function包下定义了Java 8 的丰富的函数式接口



![image-20221014174713535](E:/typora/image-20221014174713535.png)



代码演示：

```java
package com.jerry.java;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * @author jerry_jy
 * @create 2022-10-14 17:48
 */
public class LambdaTest2 {
    /*
     * java内置的4大核心函数式接口
     *
     * 消费型接口 Consumer<T>     void accept(T t)
     * 供给型接口 Supplier<T>     T get()
     * 函数型接口 Function<T,R>   R apply(T t)
     * 断定型接口 Predicate<T>    boolean test(T t)
     */
    @Test
    public void test1() {
        happyTime(500, new Consumer<Double>() {
            @Override
            public void accept(Double aDouble) {
                System.out.println("学习太累了，去天上人间买了瓶矿泉水，价格为：" + aDouble);
            }
        });
        System.out.println("********************");

        happyTime(5, money -> System.out.println("学习太累了，去天上人间喝了口水，价格为：" + money));
    }

    public void happyTime(double money, Consumer<Double> con) {
        con.accept(money);
    }

    @Test
    public void test2(){
        List<String> list = Arrays.asList("北京","南京","天津","东京","西京","普京");

        List<String> filterStrs = filterString(list, new Predicate<String>() {
            @Override
            public boolean test(String s) {
                return s.contains("京");
            }
        });

        System.out.println(filterStrs);


        List<String> filterStrs1 = filterString(list,s -> s.contains("京"));
        System.out.println(filterStrs1);
    }

    //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定
    public List<String> filterString(List<String> list, Predicate<String> pre) {
        ArrayList<String> filterList = new ArrayList<>();
        for (String s : list) {
            if (pre.test(s)){
                filterList.add(s);
            }
        }
        return filterList;
    }
}
```



## 方法引用与构造器引用

### 方法引用(Method References)

当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！ 

方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就 是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向 一个方法，可以认为是Lambda表达式的一个语法糖。 

要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的 方法的参数列表和返回值类型保持一致！ 

格式：使用操作符 “::” 将类(或对象) 与方法名分隔开来。 

如下三种主要使用情况： 

- 对象::实例方法名 
- 类::静态方法名 
- 类::实例方法名



代码演示：

```java
package com.jerry.java;

import org.junit.Test;

import java.util.Comparator;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * @author jerry_jy
 * @create 2022-10-14 18:08
 */
public class MethodRefTest {
    /*
     * 方法引用的使用
     *
     * 1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！
     *
     * 2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以
     *   方法引用，也是函数式接口的实例。
     *
     * 3. 使用格式：  类(或对象) :: 方法名
     *
     * 4. 具体分为如下的三种情况：
     *    情况1     对象 :: 非静态方法
     *    情况2     类 :: 静态方法
     *
     *    情况3     类 :: 非静态方法
     *
     * 5. 方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的
     *    形参列表和返回值类型相同！（针对于情况1和情况2）
     */

    // 情况一：对象 :: 实例方法
    //Consumer中的void accept(T t)
    //PrintStream中的void println(T t)
    @Test
    public void test1() {
        Consumer<String> con1 = str -> System.out.println(str);
        con1.accept("Tom");
        System.out.println("=======================");

        Consumer<String> con2 = System.out::println;
        con2.accept("Jerry");
    }

    //Supplier中的T get()
    //Employee中的String getName()
    @Test
    public void test2() {
        Employee emp = new Employee(1001, "Tom", 22, 2000);
        Supplier<String> sup1 = () -> emp.getName();
        System.out.println(sup1.get());
        System.out.println("====================");
        Supplier<String> sup2 = emp::getName;
        System.out.println(sup2.get());
    }

    // 情况二：类 :: 静态方法
    //Comparator中的int compare(T t1,T t2)
    //Integer中的int compare(T t1,T t2)
    @Test
    public void test3() {
        Comparator<Integer> com1 = (o1, o2) -> Integer.compare(o1, o2);
        System.out.println(com1.compare(5, 6));

        Comparator<Integer> com2 = Integer::compareTo;
        System.out.println(com2.compare(3, 4));
    }

    //Function中的R apply(T t)
    //Math中的Long round(Double d)
    @Test
    public void test4() {
        Function<Double, Long> func = new Function<Double, Long>() {
            @Override
            public Long apply(Double d) {
                return Math.round(d);
            }
        };
        System.out.println("======================");
        Function<Double, Long> func1 = d -> Math.round(d);
        System.out.println(func.apply(12.3));

        System.out.println("*******************");
        Function<Double,Long> func2 = Math::round;
        System.out.println(func2.apply(12.6));
    }
    // 情况三：类 :: 实例方法  (有难度)
    // Comparator中的int comapre(T t1,T t2)
    // String中的int t1.compareTo(t2)
    @Test
    public void test5() {
        Comparator<String> com1 = (s1,s2) -> s1.compareTo(s2);
        System.out.println(com1.compare("abc","abd"));

        System.out.println("*******************");

        Comparator<String> com2 = String :: compareTo;
        System.out.println(com2.compare("abd","abm"));
    }

    //BiPredicate中的boolean test(T t1, T t2);
    //String中的boolean t1.equals(t2)
    @Test
    public void test6() {
        BiPredicate<String,String> pre1 = (s1, s2) -> s1.equals(s2);
        System.out.println(pre1.test("abc","abc"));

        System.out.println("*******************");
        BiPredicate<String,String> pre2 = String :: equals;
        System.out.println(pre2.test("abc","abd"));
    }

    // Function中的R apply(T t)
    // Employee中的String getName();
    @Test
    public void test7() {
        Employee employee = new Employee(1001, "Jerry", 23, 6000);

        Function<Employee,String> func1 = e -> e.getName();
        System.out.println(func1.apply(employee));

        System.out.println("*******************");
        Function<Employee,String> func2 = Employee::getName;
        System.out.println(func2.apply(employee));
    }
}
```

### 构造器引用

```java
package com.jerry.java;

import org.junit.Test;

import java.util.Arrays;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * @author jerry_jy
 * @create 2022-10-14 18:30
 */
public class ConstructorRefTest {
    /*
     * 一、构造器引用
     *      和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。
     *      抽象方法的返回值类型即为构造器所属的类的类型
     *
     * 二、数组引用
     *     大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。
     */

    //构造器引用
    //Supplier中的T get()
    //Employee的空参构造器：Employee()
    @Test
    public void test1(){
        Supplier<Employee> sup = new Supplier<Employee>() {
            @Override
            public Employee get() {
                return new Employee();
            }
        };
        System.out.println(sup.get());
        System.out.println("========================");
        Supplier<Employee> sup1 = ()->new Employee();
        System.out.println(sup1.get());
        System.out.println("*******************");
        Supplier<Employee> sup2 = Employee::new;
        System.out.println(sup2.get());
    }

    //Function中的R apply(T t)
    @Test
    public void test2(){
        Function<Integer,Employee> func1 = id -> new Employee(id);
        Employee employee = func1.apply(1001);
        System.out.println(employee);

        System.out.println("*******************");

        Function<Integer,Employee> func2 = Employee :: new;
        Employee employee1 = func2.apply(1002);
        System.out.println(employee1);

    }

    //BiFunction中的R apply(T t,U u)
    @Test
    public void test3(){
        BiFunction<Integer,String,Employee> func1 = (id, name) -> new Employee(id,name);
        System.out.println(func1.apply(1001,"Tom"));

        System.out.println("*******************");

        BiFunction<Integer,String,Employee> func2 = Employee :: new;
        System.out.println(func2.apply(1002,"Tom"));

    }

    //数组引用
    //Function中的R apply(T t)
    @Test
    public void test4(){
        Function<Integer,String[]> func1 = length -> new String[length];
        String[] arr1 = func1.apply(5);
        System.out.println(Arrays.toString(arr1));

        System.out.println("*******************");

        Function<Integer,String[]> func2 = String[] :: new;
        String[] arr2 = func2.apply(10);
        System.out.println(Arrays.toString(arr2));
    }
}
```

## Stream API

Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。 也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种 高效且易于使用的处理数据的方式。



为什么要使用Stream API

- 实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数 据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要 Java层面去处理。 
- Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据 结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中， 后者主要是面向 CPU，通过 CPU 实现计算。



Stream到底是什么呢？ 

- 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 
- “集合讲的是数据，Stream讲的是计算！”

注意： 

- ①Stream 自己不会存储元素。 
- ②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 
- ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。



![image-20221014184742445](E:/typora/image-20221014184742445.png)







### 创建 Stream的四种方式

```java
package com.jerry.java;

import org.junit.Test;

import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * @author jerry_jy
 * @create 2022-10-14 18:49
 */
public class StreamAPITest {
    /*
     * 1. Stream关注的是对数据的运算，与CPU打交道
     *    集合关注的是数据的存储，与内存打交道
     *
     * 2.
     * ①Stream 自己不会存储元素。
     * ②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。
     * ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行
     *
     * 3.Stream 执行流程
     * ① Stream的实例化
     * ② 一系列的中间操作（过滤、映射、...)
     * ③ 终止操作
     *
     * 4.说明：
     * 4.1 一个中间操作链，对数据源的数据进行处理
     * 4.2 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用
     *
     *
     *  测试Stream的实例化
     */

    //创建 Stream方式一：通过集合
    @Test
    public void test1() {
        List<Employee> employees = EmployeeData.getEmployees();
//        default Stream<E> stream() : 返回一个顺序流
        Stream<Employee> stream = employees.stream();

//        default Stream<E> parallelStream() : 返回一个并行流
        Stream<Employee> parallelStream = employees.parallelStream();
    }

    //创建 Stream方式二：通过数组
    @Test
    public void test2() {
        int[] arr = new int[]{1, 2, 3, 4, 5};
        IntStream stream = Arrays.stream(arr);

        Employee e1 = new Employee(1001, "Tom");
        Employee e2 = new Employee(1002, "Jerry");
        Employee[] arr1 = new Employee[]{e1, e2};
        Stream<Employee> stream1 = Arrays.stream(arr1);
    }

    //创建 Stream方式三：通过Stream的of()
    @Test
    public void test3() {
        Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);
    }

    //创建 Stream方式四：创建无限流
    @Test
    public void test4() {
//      迭代
//      public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)
        //遍历前10个偶数
        Stream.iterate(0, t -> t + 2).limit(10).forEach(System.out::println);
//      生成
//      public static<T> Stream<T> generate(Supplier<T> s)
        Stream.generate(Math::random).limit(10).forEach(System.out::println);
    }
}
```

### Stream 的中间操作

多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止 操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全 部处理，称为“惰性求值”

#### 1-筛选与切片

![image-20221014203954175](E:/typora/image-20221014203954175.png)

```java
    //1-筛选与切片
    @Test
    public void test1(){
        List<Employee> list = EmployeeData.getEmployees();
//        filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。
        Stream<Employee> stream = list.stream();
        //练习：查询员工表中薪资大于7000的员工信息
        stream.filter(employee -> employee.getSalary()>7000).forEach(System.out::println);

        System.out.println();
//        limit(n)——截断流，使其元素不超过给定数量。
        list.stream().limit(3).forEach(System.out::println);
        System.out.println();
//        skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补
        list.stream().skip(3).forEach(System.out::println);
        System.out.println();
//        distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素

        list.add(new Employee(1010,"刘强东",40,8000));
        list.add(new Employee(1010,"刘强东",41,8000));
        list.add(new Employee(1010,"刘强东",40,8000));
        list.add(new Employee(1010,"刘强东",40,8000));
        list.add(new Employee(1010,"刘强东",40,8000));

        list.stream().distinct().forEach(System.out::println);
    }
```

#### 2-映 射

![image-20221014204050465](E:/typora/image-20221014204050465.png)

```java
    //映射
    @Test
    public void test2(){
//        map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。
        List<String> list = Arrays.asList("aa","bb","cc","dd");
        list.stream().map(s -> s.toUpperCase(Locale.ROOT)).forEach(System.out::println);
        //        练习1：获取员工姓名长度大于3的员工的姓名。
        List<Employee> employees = EmployeeData.getEmployees();
        Stream<String> stream = employees.stream().map(Employee::getName);
        stream.filter(name->name.length()>3).forEach(System.out::println);
        System.out.println();
        //练习2：
        Stream<Stream<Character>> streamStream = list.stream().map(StreamAPITest1::fromStringToStream);
        streamStream.forEach(s ->{
            s.forEach(System.out::println);
        });
        System.out.println();
    }
    //将字符串中的多个字符构成的集合转换为对应的Stream的实例
    public static Stream<Character> fromStringToStream(String str){//aa
        ArrayList<Character> list = new ArrayList<>();
        for(Character c : str.toCharArray()){
            list.add(c);
        }
        return list.stream();

    }
```

#### 3-排序

```java
    //3-排序
    @Test
    public void test4(){
//        sorted()——自然排序
        List<Integer> list = Arrays.asList(12, 43, 65, 34, 87, 0, -98, 7);
        list.stream().sorted().forEach(System.out::println);
        //抛异常，原因:Employee没有实现Comparable接口
//        List<Employee> employees = EmployeeData.getEmployees();
//        employees.stream().sorted().forEach(System.out::println);

        //        sorted(Comparator com)——定制排序
        List<Employee> employees = EmployeeData.getEmployees();
        employees.stream().sorted((e1,e2)->{
            int ageValue = Integer.compare(e1.getAge(), e2.getAge());
            if (ageValue!=0){
                return ageValue;
            }else {
                return Double.compare(e1.getSalary(), e2.getSalary());
            }
        }).forEach(System.out::println);
    }
```

### Stream 的终止操作

- 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例 如：List、Integer，甚至是 void 。 
- 流进行了终止操作后，不能再次使用。

#### 1-匹配与查找

![image-20221014204326325](E:/typora/image-20221014204326325.png)

![image-20221014204338863](E:/typora/image-20221014204338863.png)



```java
    //1-匹配与查找
    @Test
    public void test1() {
        List<Employee> employees = EmployeeData.getEmployees();

//        allMatch(Predicate p)——检查是否匹配所有元素。
//          练习：是否所有的员工的年龄都大于18
        boolean match = employees.stream().allMatch(employee -> employee.getAge() > 18);
        System.out.println(match);

//        anyMatch(Predicate p)——检查是否至少匹配一个元素。
//         练习：是否存在员工的工资大于 10000
        boolean b = employees.stream().anyMatch(employee -> employee.getSalary() > 10000);
        System.out.println(b);

//        noneMatch(Predicate p)——检查是否没有匹配的元素。
//          练习：是否存在员工姓“雷”
        boolean b1 = employees.stream().noneMatch(employee -> employee.getName().startsWith("雷"));
        System.out.println(b1);

//        findFirst——返回第一个元素
        Optional<Employee> employee = employees.stream().findFirst();
        System.out.println(employee);
//        findAny——返回当前流中的任意元素
        Optional<Employee> employee1 = employees.parallelStream().findAny();
        System.out.println(employee1);
    }

    @Test
    public void test2() {
        List<Employee> employees = EmployeeData.getEmployees();
        // count——返回流中元素的总个数
        long count = employees.stream().count();
        System.out.println(count);
//        max(Comparator c)——返回流中最大值
//        练习：返回最高的工资：
        Stream<Double> stream = employees.stream().map(employee -> employee.getSalary());
        Optional<Double> max = stream.max(Double::compareTo);
        System.out.println(max);
//        min(Comparator c)——返回流中最小值
//        练习：返回最低工资的员工
        Optional<Employee> min = employees.stream().min((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()));
        System.out.println(min);

        //        forEach(Consumer c)——内部迭代
        employees.stream().forEach(System.out::println);
        System.out.println("=====================================");
        //使用集合的遍历操作
        employees.forEach(System.out::println);
    }
```



#### 2-归约

![image-20221014204413114](E:/typora/image-20221014204413114.png)

备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google  用它来进行网络搜索而出名



```java
    //2-归约
    @Test
    public void test3() {
//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T
//        练习1：计算1-10的自然数的和
        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        Integer sum = list.stream().reduce(0, Integer::sum);
        System.out.println(sum);

//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional<T>
//        练习2：计算公司所有员工工资的总和
        List<Employee> employees = EmployeeData.getEmployees();
        Stream<Double> stream = employees.stream().map(Employee::getSalary);
        Optional<Double> sumSalary = stream.reduce(Double::sum);
        System.out.println(sumSalary);

//        Optional<Double> sumMoney = employees.stream().reduce((d1, d2) -> d1 + d2);
//        System.out.println(sumMoney.get());

    }
```



#### 3-收集

![image-20221014204506367](E:/typora/image-20221014204506367.png)



Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、 Map)。 另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例， 具体方法与实例如下表：

![image-20221014204531470](E:/typora/image-20221014204531470.png)



```java
    //3-收集
    @Test
    public void test4() {
//        collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法
//        练习1：查找工资大于6000的员工，结果返回为一个List或Set
        List<Employee> employees = EmployeeData.getEmployees();
        List<Employee> employeeList = employees.stream().filter(employee -> employee.getSalary() > 6000).collect(Collectors.toList());

        employeeList.forEach(System.out::println);
        System.out.println("====================================");
        Set<Employee> employeeSet = employees.stream().filter(employee -> employee.getSalary() > 6000).collect(Collectors.toSet());
        employeeSet.forEach(System.out::println);
```



## Optional类

到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。 以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类， Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代 码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。

Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表 这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不 存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。

Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在 则isPresent()方法会返回true，调用get()方法会返回该对象

代码演示：

```java
package com.jerry.java;

import org.junit.Test;

import java.util.Optional;

/**
 * @author jerry_jy
 * @create 2022-10-15 8:38
 */

/*
 * Optional类：为了在程序中避免出现空指针异常而创建的。
 *
 * 常用的方法：ofNullable(T t)
 *            orElse(T t)
 */
public class OptionalTest {
    /*
    Optional.of(T t) : 创建一个 Optional 实例，t必须非空；
    Optional.empty() : 创建一个空的 Optional 实例
    Optional.ofNullable(T t)：t可以为null
     */

    @Test
    public void test1(){
        Girl girl = new Girl();
//        girl=null;
        //of(T t):保证t是非空的
        Optional<Girl> optionalGirl = Optional.of(girl);

    }


    @Test
    public void test2(){
        Girl girl = new Girl();
//        girl = null;
        //ofNullable(T t)：t可以为null
        girl.setName("Tom");
        Optional<Girl> optionalGirl = Optional.ofNullable(girl);
        //orElse(T t1):如果当前的Optional内部封装的t是非空的，则返回内部的t.
        //如果内部的t是空的，则返回orElse()方法中的参数t1.
        Girl girl1 = optionalGirl.orElse(new Girl("赵丽颖"));
        System.out.println(girl1);
    }

    public String getGirlName(Boy boy){
        return boy.getGirl().getName();
    }

    @Test
    public void test3(){
        Boy boy = new Boy();
        boy = null;
        String girlName = getGirlName(boy);
        System.out.println(girlName);

    }

    //优化以后的getGirlName():
    public String getGirlName1(Boy boy){
        if(boy != null){
            Girl girl = boy.getGirl();
            if(girl != null){
                return girl.getName();
            }
        }

        return null;

    }

    @Test
    public void test4(){
        Boy boy = new Boy();
        boy = null;
        String girlName = getGirlName1(boy);
        System.out.println(girlName);
    }

    //使用Optional类的getGirlName():
    public String getGirlName2(Boy boy){

        Optional<Boy> boyOptional = Optional.ofNullable(boy);
        //此时的boy1一定非空
        Boy boy1 = boyOptional.orElse(new Boy(new Girl("迪丽热巴")));

        Girl girl = boy1.getGirl();

        Optional<Girl> girlOptional = Optional.ofNullable(girl);
        //girl1一定非空
        Girl girl1 = girlOptional.orElse(new Girl("古力娜扎"));

        return girl1.getName();
    }

    @Test
    public void test5(){
        Boy boy = null;
        boy = new Boy();
        boy = new Boy(new Girl());
        String girlName = getGirlName2(boy);
        System.out.println(girlName);

    }

}
```

